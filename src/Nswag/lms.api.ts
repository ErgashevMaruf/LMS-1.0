//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IActionHistoryClient {
    getAllActionHistory(tableMetaData: TableMetaData): Observable<QueryResultOfActionHistory>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionHistoryClient implements IActionHistoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllActionHistory(tableMetaData: TableMetaData): Observable<QueryResultOfActionHistory> {
        let url_ = this.baseUrl + "/api/LMS/ActionHistory/GetAllActionHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActionHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfActionHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfActionHistory>;
        }));
    }

    protected processGetAllActionHistory(response: HttpResponseBase): Observable<QueryResultOfActionHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfActionHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAudioClient {
    saveAudio(model: AudioDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AudioClient implements IAudioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveAudio(model: AudioDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Audio/SaveAudio";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAudio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAudio(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveAudio(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICertificateClient {
    createOrGetCertificate(courseId: number | undefined, certificateType: CertificateType | undefined): Observable<FileResponse | null>;
    getCertificateById(id: string | undefined): Observable<FileResponse | null>;
    getCertificatesByUserId(): Observable<CourseCertificateDTO[]>;
    generateCertificate(id: string | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CertificateClient implements ICertificateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOrGetCertificate(courseId: number | undefined, certificateType: CertificateType | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Certificate/CreateOrGetCertificate?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (certificateType === null)
            throw new Error("The parameter 'certificateType' cannot be null.");
        else if (certificateType !== undefined)
            url_ += "certificateType=" + encodeURIComponent("" + certificateType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrGetCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrGetCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateOrGetCertificate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCertificateById(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Certificate/GetCertificateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificateById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetCertificateById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCertificatesByUserId(): Observable<CourseCertificateDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/Certificate/GetCertificatesByUserId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificatesByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificatesByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseCertificateDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseCertificateDTO[]>;
        }));
    }

    protected processGetCertificatesByUserId(response: HttpResponseBase): Observable<CourseCertificateDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseCertificateDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generateCertificate(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Certificate/GenerateCertificate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGenerateCertificate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IContactUsClient {
    createContactUs(contactUs: ContactUsDTO): Observable<boolean>;
    getContactusList(tableMetaData: TableMetaData): Observable<QueryResultOfContactUsDTO>;
    deleteContactUsById(id: number | undefined): Observable<boolean>;
    updateContactUs(contactUs: ContactUsDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ContactUsClient implements IContactUsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createContactUs(contactUs: ContactUsDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/ContactUs/CreateContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactUs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateContactUs(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getContactusList(tableMetaData: TableMetaData): Observable<QueryResultOfContactUsDTO> {
        let url_ = this.baseUrl + "/api/LMS/ContactUs/GetContactusList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfContactUsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfContactUsDTO>;
        }));
    }

    protected processGetContactusList(response: HttpResponseBase): Observable<QueryResultOfContactUsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfContactUsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteContactUsById(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/ContactUs/DeleteContactUsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactUsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactUsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteContactUsById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateContactUs(contactUs: ContactUsDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/ContactUs/UpdateContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactUs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateContactUs(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IContentClient {
    saveContent(model: ContentDTO): Observable<boolean>;
    getAllContent(lessonId: number | undefined): Observable<QueryResultOfContentDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class ContentClient implements IContentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveContent(model: ContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Content/SaveContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllContent(lessonId: number | undefined): Observable<QueryResultOfContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/Content/GetAllContent?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfContentDTO>;
        }));
    }

    protected processGetAllContent(response: HttpResponseBase): Observable<QueryResultOfContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICoursClient {
    saveCours(model: CourseDTO): Observable<number>;
    getCourseById(id: number | undefined): Observable<CourseDTO>;
    updateCourse(model: CourseDTO): Observable<boolean>;
    getCourseTree(id: number | undefined): Observable<TreeNodes>;
    deleteCourse(id: number | undefined): Observable<boolean>;
    getCourseIdContents(id: number | undefined): Observable<CourseDTO>;
    getRemainderCourseCredit(id: number | undefined): Observable<ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean>;
    getFilterAllCourses(tableMeta: TableMetaData): Observable<QueryResultOfCourseDTO>;
    getAllCourses(tableMeta: TableMetaData): Observable<QueryResultOfCourseDTO>;
    getCourses(courseId: number | undefined): Observable<CourseDTO>;
    getCourseNameFilter(filter: string | null | undefined): Observable<string[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CoursClient implements ICoursClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveCours(model: CourseDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Cours/SaveCours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveCours(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseById(id: number | undefined): Observable<CourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetCourseById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDTO>;
        }));
    }

    protected processGetCourseById(response: HttpResponseBase): Observable<CourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCourse(model: CourseDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Cours/UpdateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateCourse(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseTree(id: number | undefined): Observable<TreeNodes> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetCourseTree?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodes>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodes>;
        }));
    }

    protected processGetCourseTree(response: HttpResponseBase): Observable<TreeNodes> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeNodes.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCourse(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Cours/DeleteCourse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteCourse(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseIdContents(id: number | undefined): Observable<CourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetCourseIdContents?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseIdContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseIdContents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDTO>;
        }));
    }

    protected processGetCourseIdContents(response: HttpResponseBase): Observable<CourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRemainderCourseCredit(id: number | undefined): Observable<ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetRemainderCourseCredit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRemainderCourseCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRemainderCourseCredit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean>;
        }));
    }

    protected processGetRemainderCourseCredit(response: HttpResponseBase): Observable<ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterAllCourses(tableMeta: TableMetaData): Observable<QueryResultOfCourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetFilterAllCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterAllCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterAllCourses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfCourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfCourseDTO>;
        }));
    }

    protected processGetFilterAllCourses(response: HttpResponseBase): Observable<QueryResultOfCourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfCourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCourses(tableMeta: TableMetaData): Observable<QueryResultOfCourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetAllCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfCourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfCourseDTO>;
        }));
    }

    protected processGetAllCourses(response: HttpResponseBase): Observable<QueryResultOfCourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfCourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourses(courseId: number | undefined): Observable<CourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetCourses?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDTO>;
        }));
    }

    protected processGetCourses(response: HttpResponseBase): Observable<CourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseNameFilter(filter: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/LMS/Cours/GetCourseNameFilter?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseNameFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseNameFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetCourseNameFilter(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICourseProgressClient {
    startCourse(courseId: number | undefined): Observable<ValueTupleOfBooleanAndString>;
    createCourseOrder(courseId: number | undefined): Observable<OrderUserForCourseDTO>;
    finishCourse(courseId: number | undefined): Observable<boolean>;
    getCourseProgressId(courseId: number | undefined): Observable<number>;
    continueCourse(courseId: number | undefined): Observable<ResponseDto>;
    restartCoursProgress(courseId: number | undefined): Observable<boolean>;
    startModule(courseId: number | undefined, moduleId: number | undefined): Observable<boolean>;
    finishModule(courseId: number | undefined, moduleId: number | undefined): Observable<boolean>;
    getCourseProgressLessonId(progressId: number | undefined, moduleId: number | undefined, lesssonId: number | undefined): Observable<number>;
    startLesson(courseId: number | undefined, moduleId: number | undefined, lesssonId: number | undefined): Observable<boolean>;
    finishLesson(courseId: number | undefined, lessonId: number | undefined, isFinished: boolean | undefined): Observable<boolean>;
    getCourseContentTree(courseId: number | undefined): Observable<TreeNodes>;
    getCourseStatisticsByStaffId(tableMetaData: TableMetaData): Observable<QueryResultOfStaffCourseStatistics>;
    getAllCourseStatistic(tableMetaData: TableMetaData): Observable<QueryResultOfStaffsCourseResults>;
}

@Injectable({
    providedIn: 'root'
})
export class CourseProgressClient implements ICourseProgressClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    startCourse(courseId: number | undefined): Observable<ValueTupleOfBooleanAndString> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/StartCourse?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfBooleanAndString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfBooleanAndString>;
        }));
    }

    protected processStartCourse(response: HttpResponseBase): Observable<ValueTupleOfBooleanAndString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfBooleanAndString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCourseOrder(courseId: number | undefined): Observable<OrderUserForCourseDTO> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/CreateCourseOrder?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCourseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCourseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderUserForCourseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderUserForCourseDTO>;
        }));
    }

    protected processCreateCourseOrder(response: HttpResponseBase): Observable<OrderUserForCourseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderUserForCourseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finishCourse(courseId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/FinishCourse?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFinishCourse(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseProgressId(courseId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/GetCourseProgressId?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseProgressId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseProgressId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCourseProgressId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    continueCourse(courseId: number | undefined): Observable<ResponseDto> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/ContinueCourse?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContinueCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContinueCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDto>;
        }));
    }

    protected processContinueCourse(response: HttpResponseBase): Observable<ResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    restartCoursProgress(courseId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/RestartCoursProgress?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestartCoursProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestartCoursProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRestartCoursProgress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startModule(courseId: number | undefined, moduleId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/StartModule?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStartModule(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finishModule(courseId: number | undefined, moduleId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/FinishModule?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFinishModule(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseProgressLessonId(progressId: number | undefined, moduleId: number | undefined, lesssonId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/GetCourseProgressLessonId?";
        if (progressId === null)
            throw new Error("The parameter 'progressId' cannot be null.");
        else if (progressId !== undefined)
            url_ += "progressId=" + encodeURIComponent("" + progressId) + "&";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (lesssonId === null)
            throw new Error("The parameter 'lesssonId' cannot be null.");
        else if (lesssonId !== undefined)
            url_ += "lesssonId=" + encodeURIComponent("" + lesssonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseProgressLessonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseProgressLessonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCourseProgressLessonId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startLesson(courseId: number | undefined, moduleId: number | undefined, lesssonId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/StartLesson?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (lesssonId === null)
            throw new Error("The parameter 'lesssonId' cannot be null.");
        else if (lesssonId !== undefined)
            url_ += "lesssonId=" + encodeURIComponent("" + lesssonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStartLesson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finishLesson(courseId: number | undefined, lessonId: number | undefined, isFinished: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/FinishLesson?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        if (isFinished === null)
            throw new Error("The parameter 'isFinished' cannot be null.");
        else if (isFinished !== undefined)
            url_ += "isFinished=" + encodeURIComponent("" + isFinished) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFinishLesson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseContentTree(courseId: number | undefined): Observable<TreeNodes> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/GetCourseContentTree?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseContentTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseContentTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodes>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodes>;
        }));
    }

    protected processGetCourseContentTree(response: HttpResponseBase): Observable<TreeNodes> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeNodes.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseStatisticsByStaffId(tableMetaData: TableMetaData): Observable<QueryResultOfStaffCourseStatistics> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/GetCourseStatisticsByStaffId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseStatisticsByStaffId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseStatisticsByStaffId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfStaffCourseStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfStaffCourseStatistics>;
        }));
    }

    protected processGetCourseStatisticsByStaffId(response: HttpResponseBase): Observable<QueryResultOfStaffCourseStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfStaffCourseStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCourseStatistic(tableMetaData: TableMetaData): Observable<QueryResultOfStaffsCourseResults> {
        let url_ = this.baseUrl + "/api/LMS/CourseProgress/GetAllCourseStatistic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourseStatistic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourseStatistic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfStaffsCourseResults>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfStaffsCourseResults>;
        }));
    }

    protected processGetAllCourseStatistic(response: HttpResponseBase): Observable<QueryResultOfStaffsCourseResults> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfStaffsCourseResults.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDiscussionAnswerClient {
    saveDiscussionAnswer(model: TaskDiscussionAnswerDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class DiscussionAnswerClient implements IDiscussionAnswerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveDiscussionAnswer(model: TaskDiscussionAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/DiscussionAnswer/SaveDiscussionAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDiscussionAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDiscussionAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveDiscussionAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDiscussionClient {
    saveDiscussion(discussion: TaskDiscussionDTO): Observable<boolean>;
    getByIdDiscussion(id: number | undefined): Observable<TaskDiscussionDTO>;
    getByIdTaskDiscussionAnswers(id: number | undefined): Observable<TaskDiscussionDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class DiscussionClient implements IDiscussionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveDiscussion(discussion: TaskDiscussionDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Discussion/SaveDiscussion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(discussion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDiscussion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDiscussion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveDiscussion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdDiscussion(id: number | undefined): Observable<TaskDiscussionDTO> {
        let url_ = this.baseUrl + "/api/LMS/Discussion/GetByIdDiscussion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdDiscussion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdDiscussion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaskDiscussionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaskDiscussionDTO>;
        }));
    }

    protected processGetByIdDiscussion(response: HttpResponseBase): Observable<TaskDiscussionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskDiscussionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdTaskDiscussionAnswers(id: number | undefined): Observable<TaskDiscussionDTO> {
        let url_ = this.baseUrl + "/api/LMS/Discussion/GetByIdTaskDiscussionAnswers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdTaskDiscussionAnswers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdTaskDiscussionAnswers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaskDiscussionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaskDiscussionDTO>;
        }));
    }

    protected processGetByIdTaskDiscussionAnswers(response: HttpResponseBase): Observable<TaskDiscussionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskDiscussionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDocumentClient {
    saveDocumentContent(model: DocumentContentDTO): Observable<boolean>;
    getAllDocumentContent(lessonId: number | undefined): Observable<QueryResultOfDocumentContentDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class DocumentClient implements IDocumentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveDocumentContent(model: DocumentContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Document/SaveDocumentContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDocumentContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDocumentContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveDocumentContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllDocumentContent(lessonId: number | undefined): Observable<QueryResultOfDocumentContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/Document/GetAllDocumentContent?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDocumentContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDocumentContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfDocumentContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfDocumentContentDTO>;
        }));
    }

    protected processGetAllDocumentContent(response: HttpResponseBase): Observable<QueryResultOfDocumentContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfDocumentContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilesClient {
    getImageByIdFromFolderInBase64(id: string): Observable<string>;
    getImageFile(id: string): Observable<FileResponse | null>;
    getVideoByIdFromFolderInBase64(id: string): Observable<string>;
    getVideoStream(id: string): Observable<FileResponse | null>;
    getDocumentByIdFromFolderInBase64(id: string): Observable<DocumentDTO>;
    uploadForAudio(): Observable<FileResponse | null>;
    uploadForDocument(): Observable<FileResponse | null>;
    uploadForImage(): Observable<FileResponse | null>;
    uploadForImageBase64(base64Image: string): Observable<string>;
    uploadForVideo(): Observable<FileResponse | null>;
    getAudioByIdFromFolderBase64(id: string | undefined): Observable<string>;
    deleteImageById(id: string | undefined): Observable<boolean>;
    deleteImagesById(ids: string[]): Observable<FileResponse | null>;
    deleteFileVideoById(id: string | undefined): Observable<FileResponse | null>;
    deleteFileAudioById(id: string | undefined): Observable<FileResponse | null>;
    deleteFileDocumentById(id: string | undefined): Observable<FileResponse | null>;
    uploadLargeVideo(): Observable<FileResponse | null>;
    getVideo(id: string | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getImageByIdFromFolderInBase64(id: string): Observable<string> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetImageByIdFromFolderInBase64/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageByIdFromFolderInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageByIdFromFolderInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetImageByIdFromFolderInBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageFile(id: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetImageFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetImageFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoByIdFromFolderInBase64(id: string): Observable<string> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetVideoByIdFromFolderInBase64/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoByIdFromFolderInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoByIdFromFolderInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVideoByIdFromFolderInBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoStream(id: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetVideoStream/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoStream(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetVideoStream(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDocumentByIdFromFolderInBase64(id: string): Observable<DocumentDTO> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetDocumentByIdFromFolderInBase64/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentByIdFromFolderInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentByIdFromFolderInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentDTO>;
        }));
    }

    protected processGetDocumentByIdFromFolderInBase64(response: HttpResponseBase): Observable<DocumentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForAudio(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/uploadForAudio";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForAudio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForAudio(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForAudio(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForDocument(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/uploadForDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForDocument(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForImage(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/uploadForImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForImage(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForImageBase64(base64Image: string): Observable<string> {
        let url_ = this.baseUrl + "/api/LMS/Files/uploadForImageBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(base64Image);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForImageBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForImageBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadForImageBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForVideo(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/uploadForVideo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForVideo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAudioByIdFromFolderBase64(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetAudioByIdFromFolderBase64?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAudioByIdFromFolderBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAudioByIdFromFolderBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAudioByIdFromFolderBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImageById(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Files/DeleteImageById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteImageById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImagesById(ids: string[]): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/DeleteImagesById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImagesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImagesById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteImagesById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFileVideoById(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/DeleteFileVideoById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFileVideoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFileVideoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteFileVideoById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFileAudioById(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/DeleteFileAudioById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFileAudioById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFileAudioById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteFileAudioById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFileDocumentById(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/DeleteFileDocumentById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFileDocumentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFileDocumentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteFileDocumentById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadLargeVideo(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/UploadLargeVideo/upload-stream-multipartreader";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLargeVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLargeVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadLargeVideo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideo(id: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Files/GetVideo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetVideo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFormThemeClient {
    createFormTheme(form: FormThemeDTO): Observable<boolean>;
    formThemeConfirmation(formThemeId: number | undefined): Observable<boolean>;
    updateFormTheme(form: FormThemeDTO): Observable<boolean>;
    getFormThemeById(themeId: number | undefined): Observable<ValueTupleOfFormThemeDTOAndBoolean>;
    getFormThemesCreatedByUser(): Observable<FormThemeDTO[]>;
    getALLFormThemes(tableMeta: TableMetaData): Observable<QueryResultOfFormThemeDTO>;
    deleteFormTheme(formThemeId: number | undefined): Observable<boolean>;
    createCommentToFormTheme(comment: FormCommentDTO): Observable<FormCommentDTO>;
    deleteFormComment(commentId: number | undefined): Observable<boolean>;
    updateFormComment(comment: FormCommentDTO): Observable<FormCommentDTO>;
    getFormCommentListByCommentId(commentId: number | undefined): Observable<FormCommentDTO[]>;
    createCommentToFormComment(comment: FormCommentDTO): Observable<FormCommentDTO>;
    createOrUpdateLikeOrDislikeToFormTheme(themeLike: FormThemeLikeDTO): Observable<boolean>;
    createOrUpdateLikeOrDislikeToFormComment(commentLike: FormCommentLikeDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class FormThemeClient implements IFormThemeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createFormTheme(form: FormThemeDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/CreateFormTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFormTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFormTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateFormTheme(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    formThemeConfirmation(formThemeId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/FormThemeConfirmation?";
        if (formThemeId === null)
            throw new Error("The parameter 'formThemeId' cannot be null.");
        else if (formThemeId !== undefined)
            url_ += "formThemeId=" + encodeURIComponent("" + formThemeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormThemeConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormThemeConfirmation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFormThemeConfirmation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateFormTheme(form: FormThemeDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/UpdateFormTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFormTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFormTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateFormTheme(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFormThemeById(themeId: number | undefined): Observable<ValueTupleOfFormThemeDTOAndBoolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/GetFormThemeById?";
        if (themeId === null)
            throw new Error("The parameter 'themeId' cannot be null.");
        else if (themeId !== undefined)
            url_ += "themeId=" + encodeURIComponent("" + themeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormThemeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormThemeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfFormThemeDTOAndBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfFormThemeDTOAndBoolean>;
        }));
    }

    protected processGetFormThemeById(response: HttpResponseBase): Observable<ValueTupleOfFormThemeDTOAndBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfFormThemeDTOAndBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFormThemesCreatedByUser(): Observable<FormThemeDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/GetFormThemesCreatedByUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormThemesCreatedByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormThemesCreatedByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormThemeDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormThemeDTO[]>;
        }));
    }

    protected processGetFormThemesCreatedByUser(response: HttpResponseBase): Observable<FormThemeDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormThemeDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getALLFormThemes(tableMeta: TableMetaData): Observable<QueryResultOfFormThemeDTO> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/GetALLFormThemes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetALLFormThemes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetALLFormThemes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfFormThemeDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfFormThemeDTO>;
        }));
    }

    protected processGetALLFormThemes(response: HttpResponseBase): Observable<QueryResultOfFormThemeDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfFormThemeDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFormTheme(formThemeId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/DeleteFormTheme?";
        if (formThemeId === null)
            throw new Error("The parameter 'formThemeId' cannot be null.");
        else if (formThemeId !== undefined)
            url_ += "formThemeId=" + encodeURIComponent("" + formThemeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteFormTheme(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCommentToFormTheme(comment: FormCommentDTO): Observable<FormCommentDTO> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/CreateCommentToFormTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCommentToFormTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCommentToFormTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormCommentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormCommentDTO>;
        }));
    }

    protected processCreateCommentToFormTheme(response: HttpResponseBase): Observable<FormCommentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormCommentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFormComment(commentId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/DeleteFormComment?";
        if (commentId === null)
            throw new Error("The parameter 'commentId' cannot be null.");
        else if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteFormComment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateFormComment(comment: FormCommentDTO): Observable<FormCommentDTO> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/UpdateFormComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFormComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFormComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormCommentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormCommentDTO>;
        }));
    }

    protected processUpdateFormComment(response: HttpResponseBase): Observable<FormCommentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormCommentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFormCommentListByCommentId(commentId: number | undefined): Observable<FormCommentDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/GetFormCommentListByCommentId?";
        if (commentId === null)
            throw new Error("The parameter 'commentId' cannot be null.");
        else if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormCommentListByCommentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormCommentListByCommentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormCommentDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormCommentDTO[]>;
        }));
    }

    protected processGetFormCommentListByCommentId(response: HttpResponseBase): Observable<FormCommentDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormCommentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCommentToFormComment(comment: FormCommentDTO): Observable<FormCommentDTO> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/CreateCommentToFormComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCommentToFormComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCommentToFormComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormCommentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormCommentDTO>;
        }));
    }

    protected processCreateCommentToFormComment(response: HttpResponseBase): Observable<FormCommentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormCommentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrUpdateLikeOrDislikeToFormTheme(themeLike: FormThemeLikeDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/CreateOrUpdateLikeOrDislikeToFormTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(themeLike);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLikeOrDislikeToFormTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLikeOrDislikeToFormTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateOrUpdateLikeOrDislikeToFormTheme(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrUpdateLikeOrDislikeToFormComment(commentLike: FormCommentLikeDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/FormTheme/CreateOrUpdateLikeOrDislikeToFormComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commentLike);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLikeOrDislikeToFormComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLikeOrDislikeToFormComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateOrUpdateLikeOrDislikeToFormComment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGeneralContentClient {
    saveContent(model: GeneralContentDTO): Observable<boolean>;
    updateGeneralContent(model: GeneralContentDTO): Observable<boolean>;
    orderChangeGeneralContent(id: number | undefined, isOrderHigh: boolean | undefined): Observable<boolean>;
    deleteGeneralContent(id: number | undefined): Observable<boolean>;
    getAllContent(lessonId: number | undefined): Observable<QueryResultOfGeneralContentDTO>;
    getByIdContent(contentId: number | undefined): Observable<GeneralContentDTO>;
    getByIdContentForAdmin(contentId: number | undefined): Observable<GeneralContentDTO>;
    getNextContent(curContentId: number | undefined): Observable<GeneralContentDTO>;
    getPrewContent(curContentId: number | undefined): Observable<GeneralContentDTO>;
    getByLessonIdContent(contentId: number | undefined): Observable<GeneralContentDTO[]>;
    getByUserIdLastContent(courseId: number | undefined): Observable<UserLastStepContentDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class GeneralContentClient implements IGeneralContentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveContent(model: GeneralContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/SaveContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateGeneralContent(model: GeneralContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/UpdateGeneralContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateGeneralContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    orderChangeGeneralContent(id: number | undefined, isOrderHigh: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/OrderChangeGeneralContent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isOrderHigh === null)
            throw new Error("The parameter 'isOrderHigh' cannot be null.");
        else if (isOrderHigh !== undefined)
            url_ += "isOrderHigh=" + encodeURIComponent("" + isOrderHigh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderChangeGeneralContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderChangeGeneralContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrderChangeGeneralContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteGeneralContent(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/DeleteGeneralContent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGeneralContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGeneralContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteGeneralContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllContent(lessonId: number | undefined): Observable<QueryResultOfGeneralContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetAllContent?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfGeneralContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfGeneralContentDTO>;
        }));
    }

    protected processGetAllContent(response: HttpResponseBase): Observable<QueryResultOfGeneralContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfGeneralContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdContent(contentId: number | undefined): Observable<GeneralContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetByIdContent?";
        if (contentId === null)
            throw new Error("The parameter 'contentId' cannot be null.");
        else if (contentId !== undefined)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContentDTO>;
        }));
    }

    protected processGetByIdContent(response: HttpResponseBase): Observable<GeneralContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdContentForAdmin(contentId: number | undefined): Observable<GeneralContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetByIdContentForAdmin?";
        if (contentId === null)
            throw new Error("The parameter 'contentId' cannot be null.");
        else if (contentId !== undefined)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdContentForAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdContentForAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContentDTO>;
        }));
    }

    protected processGetByIdContentForAdmin(response: HttpResponseBase): Observable<GeneralContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNextContent(curContentId: number | undefined): Observable<GeneralContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetNextContent?";
        if (curContentId === null)
            throw new Error("The parameter 'curContentId' cannot be null.");
        else if (curContentId !== undefined)
            url_ += "CurContentId=" + encodeURIComponent("" + curContentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContentDTO>;
        }));
    }

    protected processGetNextContent(response: HttpResponseBase): Observable<GeneralContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPrewContent(curContentId: number | undefined): Observable<GeneralContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetPrewContent?";
        if (curContentId === null)
            throw new Error("The parameter 'curContentId' cannot be null.");
        else if (curContentId !== undefined)
            url_ += "CurContentId=" + encodeURIComponent("" + curContentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrewContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrewContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContentDTO>;
        }));
    }

    protected processGetPrewContent(response: HttpResponseBase): Observable<GeneralContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByLessonIdContent(contentId: number | undefined): Observable<GeneralContentDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetByLessonIdContent?";
        if (contentId === null)
            throw new Error("The parameter 'contentId' cannot be null.");
        else if (contentId !== undefined)
            url_ += "contentId=" + encodeURIComponent("" + contentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLessonIdContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLessonIdContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralContentDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralContentDTO[]>;
        }));
    }

    protected processGetByLessonIdContent(response: HttpResponseBase): Observable<GeneralContentDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GeneralContentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByUserIdLastContent(courseId: number | undefined): Observable<UserLastStepContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/GeneralContent/GetByUserIdLastContent?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserIdLastContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserIdLastContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLastStepContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLastStepContentDTO>;
        }));
    }

    protected processGetByUserIdLastContent(response: HttpResponseBase): Observable<UserLastStepContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLastStepContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGiveFeedbackClient {
    saveGiveFeedback(model: GiveFeedbackDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class GiveFeedbackClient implements IGiveFeedbackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveGiveFeedback(model: GiveFeedbackDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/GiveFeedback/SaveGiveFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGiveFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGiveFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveGiveFeedback(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IJoinCourseClient {
    staffJoinCourse(courseId: number | undefined, staffId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class JoinCourseClient implements IJoinCourseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    staffJoinCourse(courseId: number | undefined, staffId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/JoinCourse/StaffJoinCourse?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStaffJoinCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStaffJoinCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processStaffJoinCourse(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILessonClient {
    saveLesson(model: LessonDTO, moduleId: number | undefined): Observable<number>;
    orderChangeLesson(id: number | undefined, isOrderHigh: boolean | undefined): Observable<boolean>;
    getLessonByIdContents(id: number | undefined): Observable<LessonDTO>;
    deleteLesson(lessonId: number | undefined): Observable<boolean>;
    updateLesson(model: LessonDTO): Observable<boolean>;
    getAllForDataTableLessons(tableMeta: TableMetaData, moduleId: number | undefined): Observable<QueryResultOfLessonDTO>;
    getAllLessons(moduleId: number | undefined): Observable<QueryResultOfLessonDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class LessonClient implements ILessonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveLesson(model: LessonDTO, moduleId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/SaveLesson?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveLesson(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    orderChangeLesson(id: number | undefined, isOrderHigh: boolean | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/OrderChangeLesson?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isOrderHigh === null)
            throw new Error("The parameter 'isOrderHigh' cannot be null.");
        else if (isOrderHigh !== undefined)
            url_ += "isOrderHigh=" + encodeURIComponent("" + isOrderHigh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderChangeLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderChangeLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrderChangeLesson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLessonByIdContents(id: number | undefined): Observable<LessonDTO> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/GetLessonByIdContents?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLessonByIdContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLessonByIdContents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LessonDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LessonDTO>;
        }));
    }

    protected processGetLessonByIdContents(response: HttpResponseBase): Observable<LessonDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LessonDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteLesson(lessonId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/DeleteLesson?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteLesson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateLesson(model: LessonDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/UpdateLesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLesson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLesson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateLesson(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllForDataTableLessons(tableMeta: TableMetaData, moduleId: number | undefined): Observable<QueryResultOfLessonDTO> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/GetAllForDataTableLessons?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForDataTableLessons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForDataTableLessons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfLessonDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfLessonDTO>;
        }));
    }

    protected processGetAllForDataTableLessons(response: HttpResponseBase): Observable<QueryResultOfLessonDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfLessonDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllLessons(moduleId: number | undefined): Observable<QueryResultOfLessonDTO> {
        let url_ = this.baseUrl + "/api/LMS/Lesson/GetAllLessons?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLessons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLessons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfLessonDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfLessonDTO>;
        }));
    }

    protected processGetAllLessons(response: HttpResponseBase): Observable<QueryResultOfLessonDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfLessonDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModuleClient {
    getModuleId(moduleId: number | undefined): Observable<ModuleDTO>;
    deleteModule(moduleId: number | undefined): Observable<boolean>;
    orderChangeModule(moduleId1: number | undefined, moduleId2: number | undefined): Observable<boolean>;
    updateModule(module: ModuleDTO): Observable<boolean>;
    orderChangeModuleContent(gpmId1: number | undefined, gpmId2: number | undefined): Observable<boolean>;
    saveModule(model: ModuleDTO): Observable<number>;
    getAllModules(courseId: number | undefined): Observable<QueryResultOfModuleDTO>;
    getAllTreeModules(courseId: number | undefined): Observable<TreeNodes[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ModuleClient implements IModuleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getModuleId(moduleId: number | undefined): Observable<ModuleDTO> {
        let url_ = this.baseUrl + "/api/LMS/Module/GetModuleId?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDTO>;
        }));
    }

    protected processGetModuleId(response: HttpResponseBase): Observable<ModuleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteModule(moduleId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Module/DeleteModule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteModule(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    orderChangeModule(moduleId1: number | undefined, moduleId2: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Module/OrderChangeModule?";
        if (moduleId1 === null)
            throw new Error("The parameter 'moduleId1' cannot be null.");
        else if (moduleId1 !== undefined)
            url_ += "moduleId1=" + encodeURIComponent("" + moduleId1) + "&";
        if (moduleId2 === null)
            throw new Error("The parameter 'moduleId2' cannot be null.");
        else if (moduleId2 !== undefined)
            url_ += "moduleId2=" + encodeURIComponent("" + moduleId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderChangeModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderChangeModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrderChangeModule(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateModule(module: ModuleDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Module/UpdateModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(module);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateModule(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    orderChangeModuleContent(gpmId1: number | undefined, gpmId2: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Module/OrderChangeModuleContent?";
        if (gpmId1 === null)
            throw new Error("The parameter 'gpmId1' cannot be null.");
        else if (gpmId1 !== undefined)
            url_ += "gpmId1=" + encodeURIComponent("" + gpmId1) + "&";
        if (gpmId2 === null)
            throw new Error("The parameter 'gpmId2' cannot be null.");
        else if (gpmId2 !== undefined)
            url_ += "gpmId2=" + encodeURIComponent("" + gpmId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderChangeModuleContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderChangeModuleContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrderChangeModuleContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveModule(model: ModuleDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Module/SaveModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveModule(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllModules(courseId: number | undefined): Observable<QueryResultOfModuleDTO> {
        let url_ = this.baseUrl + "/api/LMS/Module/GetAllModules?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfModuleDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfModuleDTO>;
        }));
    }

    protected processGetAllModules(response: HttpResponseBase): Observable<QueryResultOfModuleDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfModuleDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTreeModules(courseId: number | undefined): Observable<TreeNodes[]> {
        let url_ = this.baseUrl + "/api/LMS/Module/GetAllTreeModules?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTreeModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTreeModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeNodes[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeNodes[]>;
        }));
    }

    protected processGetAllTreeModules(response: HttpResponseBase): Observable<TreeNodes[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNodes.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INotificationClient {
    getAllNotification(): Observable<ValueTupleOfListOfNotificationDTOAndInteger>;
    viewNotification(notificationId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationClient implements INotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllNotification(): Observable<ValueTupleOfListOfNotificationDTOAndInteger> {
        let url_ = this.baseUrl + "/api/LMS/Notification/GetAllNotification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfListOfNotificationDTOAndInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfListOfNotificationDTOAndInteger>;
        }));
    }

    protected processGetAllNotification(response: HttpResponseBase): Observable<ValueTupleOfListOfNotificationDTOAndInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfListOfNotificationDTOAndInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    viewNotification(notificationId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Notification/ViewNotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processViewNotification(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrganizationClient {
    addOrganization(orgModel: OrganizationDTO): Observable<boolean>;
    getOrganizationIdbyDomein(domein: string): Observable<number>;
    getAllOrganization(metaData: TableMetaData): Observable<QueryResultOfOrganizationDTO>;
    deleteOrganization(id: number | undefined): Observable<boolean>;
    updateOrganization(orgModel: OrganizationDTO): Observable<boolean>;
    getAllOrganizations(): Observable<SelectItem[]>;
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationClient implements IOrganizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addOrganization(orgModel: OrganizationDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Organization/AddOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orgModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddOrganization(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrganizationIdbyDomein(domein: string): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Organization/GetOrganizationIdbyDomein";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(domein);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationIdbyDomein(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationIdbyDomein(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetOrganizationIdbyDomein(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllOrganization(metaData: TableMetaData): Observable<QueryResultOfOrganizationDTO> {
        let url_ = this.baseUrl + "/api/LMS/Organization/GetAllOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(metaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfOrganizationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfOrganizationDTO>;
        }));
    }

    protected processGetAllOrganization(response: HttpResponseBase): Observable<QueryResultOfOrganizationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfOrganizationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOrganization(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Organization/DeleteOrganization?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteOrganization(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOrganization(orgModel: OrganizationDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Organization/UpdateOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orgModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateOrganization(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllOrganizations(): Observable<SelectItem[]> {
        let url_ = this.baseUrl + "/api/LMS/Organization/GetAllOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItem[]>;
        }));
    }

    protected processGetAllOrganizations(response: HttpResponseBase): Observable<SelectItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPaymentClient {
    payme(model: PaymeViewModel): Observable<PaymeResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PaymentClient implements IPaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    payme(model: PaymeViewModel): Observable<PaymeResponse> {
        let url_ = this.baseUrl + "/api/LMS/payment/payme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymeResponse>;
        }));
    }

    protected processPayme(response: HttpResponseBase): Observable<PaymeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPeerReviewAnswerClient {
    savePeerReviewAnswer(model: PeerReviewAnswerDTO): Observable<boolean>;
    getAllPeerReviewAnswerByPeerId(peerReviewId: number | undefined): Observable<PeerReviewAnswerDTO[]>;
    getByIdAnswerWithGiveFeedback(answerId: number | undefined): Observable<PeerReviewAnswerDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class PeerReviewAnswerClient implements IPeerReviewAnswerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    savePeerReviewAnswer(model: PeerReviewAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/PeerReviewAnswer/SavePeerReviewAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePeerReviewAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePeerReviewAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSavePeerReviewAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPeerReviewAnswerByPeerId(peerReviewId: number | undefined): Observable<PeerReviewAnswerDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/PeerReviewAnswer/GetAllPeerReviewAnswerByPeerId?";
        if (peerReviewId === null)
            throw new Error("The parameter 'peerReviewId' cannot be null.");
        else if (peerReviewId !== undefined)
            url_ += "peerReviewId=" + encodeURIComponent("" + peerReviewId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPeerReviewAnswerByPeerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPeerReviewAnswerByPeerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeerReviewAnswerDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeerReviewAnswerDTO[]>;
        }));
    }

    protected processGetAllPeerReviewAnswerByPeerId(response: HttpResponseBase): Observable<PeerReviewAnswerDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PeerReviewAnswerDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdAnswerWithGiveFeedback(answerId: number | undefined): Observable<PeerReviewAnswerDTO> {
        let url_ = this.baseUrl + "/api/LMS/PeerReviewAnswer/GetByIdAnswerWithGiveFeedback?";
        if (answerId === null)
            throw new Error("The parameter 'answerId' cannot be null.");
        else if (answerId !== undefined)
            url_ += "answerId=" + encodeURIComponent("" + answerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdAnswerWithGiveFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdAnswerWithGiveFeedback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeerReviewAnswerDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeerReviewAnswerDTO>;
        }));
    }

    protected processGetByIdAnswerWithGiveFeedback(response: HttpResponseBase): Observable<PeerReviewAnswerDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeerReviewAnswerDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPeerReviewClient {
    savePeerReview(model: PeerReviewDTO): Observable<boolean>;
    getAllPeerReviews(): Observable<PeerReviewDTO[]>;
    getByIdPeerReview(id: number | undefined): Observable<PeerReviewDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class PeerReviewClient implements IPeerReviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    savePeerReview(model: PeerReviewDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/PeerReview/SavePeerReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePeerReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePeerReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSavePeerReview(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPeerReviews(): Observable<PeerReviewDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/PeerReview/GetAllPeerReviews";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPeerReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPeerReviews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeerReviewDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeerReviewDTO[]>;
        }));
    }

    protected processGetAllPeerReviews(response: HttpResponseBase): Observable<PeerReviewDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PeerReviewDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdPeerReview(id: number | undefined): Observable<PeerReviewDTO> {
        let url_ = this.baseUrl + "/api/LMS/PeerReview/GetByIdPeerReview?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdPeerReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdPeerReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeerReviewDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeerReviewDTO>;
        }));
    }

    protected processGetByIdPeerReview(response: HttpResponseBase): Observable<PeerReviewDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeerReviewDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPhotoClient {
    savePhotoContent(model: PhotoContentDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class PhotoClient implements IPhotoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    savePhotoContent(model: PhotoContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Photo/SavePhotoContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePhotoContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePhotoContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSavePhotoContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuestionClient {
    saveTest(model: TestDTO): Observable<number>;
    getTestById(id: number | undefined): Observable<TestDTO>;
    saveQuestion(model: TQuestionDTO): Observable<number>;
    saveQuestionlist(model: TQuestionDTO[]): Observable<boolean>;
    saveAnswer(model: TQuestionAnswerDTO): Observable<boolean>;
    getAllQuestionByTestId(testId: number | undefined, testCount: number | undefined): Observable<TQuestionDTO[]>;
}

@Injectable({
    providedIn: 'root'
})
export class QuestionClient implements IQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveTest(model: TestDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Question/SaveTest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveTest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTestById(id: number | undefined): Observable<TestDTO> {
        let url_ = this.baseUrl + "/api/LMS/Question/GetTestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDTO>;
        }));
    }

    protected processGetTestById(response: HttpResponseBase): Observable<TestDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveQuestion(model: TQuestionDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Question/SaveQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveQuestion(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveQuestionlist(model: TQuestionDTO[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Question/SaveQuestionlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuestionlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuestionlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveQuestionlist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveAnswer(model: TQuestionAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Question/SaveAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllQuestionByTestId(testId: number | undefined, testCount: number | undefined): Observable<TQuestionDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/Question/GetAllQuestionByTestId?";
        if (testId === null)
            throw new Error("The parameter 'testId' cannot be null.");
        else if (testId !== undefined)
            url_ += "testId=" + encodeURIComponent("" + testId) + "&";
        if (testCount === null)
            throw new Error("The parameter 'testCount' cannot be null.");
        else if (testCount !== undefined)
            url_ += "testCount=" + encodeURIComponent("" + testCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuestionByTestId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuestionByTestId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TQuestionDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TQuestionDTO[]>;
        }));
    }

    protected processGetAllQuestionByTestId(response: HttpResponseBase): Observable<TQuestionDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TQuestionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuizClient {
    saveQuiz(model: QuizDTO, moduleId: number | undefined): Observable<number>;
    saveQuizToCourse(model: QuizDTO): Observable<number>;
    getQuizById(id: number | undefined): Observable<QuizDTO>;
    getQuizByIdLevelsCategories(id: number | undefined): Observable<QuizDTO>;
    getCourseInitialQuizId(courseId: number | null | undefined): Observable<ValueTupleOfIntegerAndBoolean>;
    getCourseFinalQuizId(courseId: number | null | undefined): Observable<ValueTupleOfIntegerAndBoolean>;
    updateQuiz(quiz: QuizDTO): Observable<FileResponse | null>;
    deleteQuiz(id: number | undefined): Observable<FileResponse | null>;
    deleteQuizQuestionCategoryById(categoryId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuizClient implements IQuizClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveQuiz(model: QuizDTO, moduleId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/SaveQuiz?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveQuiz(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveQuizToCourse(model: QuizDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/SaveQuizToCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuizToCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuizToCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveQuizToCourse(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizById(id: number | undefined): Observable<QuizDTO> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/GetQuizById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizDTO>;
        }));
    }

    protected processGetQuizById(response: HttpResponseBase): Observable<QuizDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizByIdLevelsCategories(id: number | undefined): Observable<QuizDTO> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/GetQuizByIdLevelsCategories?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizByIdLevelsCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizByIdLevelsCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizDTO>;
        }));
    }

    protected processGetQuizByIdLevelsCategories(response: HttpResponseBase): Observable<QuizDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseInitialQuizId(courseId: number | null | undefined): Observable<ValueTupleOfIntegerAndBoolean> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/GetCourseInitialQuizId?";
        if (courseId !== undefined && courseId !== null)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseInitialQuizId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseInitialQuizId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfIntegerAndBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfIntegerAndBoolean>;
        }));
    }

    protected processGetCourseInitialQuizId(response: HttpResponseBase): Observable<ValueTupleOfIntegerAndBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfIntegerAndBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourseFinalQuizId(courseId: number | null | undefined): Observable<ValueTupleOfIntegerAndBoolean> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/GetCourseFinalQuizId?";
        if (courseId !== undefined && courseId !== null)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseFinalQuizId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseFinalQuizId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfIntegerAndBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfIntegerAndBoolean>;
        }));
    }

    protected processGetCourseFinalQuizId(response: HttpResponseBase): Observable<ValueTupleOfIntegerAndBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfIntegerAndBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuiz(quiz: QuizDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/UpdateQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quiz);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateQuiz(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuiz(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/DeleteQuiz?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteQuiz(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuizQuestionCategoryById(categoryId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Quiz/DeleteQuizQuestionCategoryById?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuizQuestionCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuizQuestionCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteQuizQuestionCategoryById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuizLevelQuestionClient {
    getAllQuestionsByQuizId(quizId: number | undefined): Observable<QuizLevelQuestionDTO[]>;
    deleteQuizLevelById(levelId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuizLevelQuestionClient implements IQuizLevelQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllQuestionsByQuizId(quizId: number | undefined): Observable<QuizLevelQuestionDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/QuizLevelQuestion/GetAllQuestionsByQuizId?";
        if (quizId === null)
            throw new Error("The parameter 'quizId' cannot be null.");
        else if (quizId !== undefined)
            url_ += "quizId=" + encodeURIComponent("" + quizId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuestionsByQuizId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuestionsByQuizId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizLevelQuestionDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizLevelQuestionDTO[]>;
        }));
    }

    protected processGetAllQuestionsByQuizId(response: HttpResponseBase): Observable<QuizLevelQuestionDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuizLevelQuestionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuizLevelById(levelId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizLevelQuestion/DeleteQuizLevelById?";
        if (levelId === null)
            throw new Error("The parameter 'levelId' cannot be null.");
        else if (levelId !== undefined)
            url_ += "levelId=" + encodeURIComponent("" + levelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuizLevelById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuizLevelById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteQuizLevelById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuizQuestionClient {
    createQuizQuestionList(questions: QuizQuestionDTO[]): Observable<boolean>;
    updateQuizQuestionList(questions: QuizQuestionDTO[]): Observable<boolean>;
    updateQuizQuestion(model: QuizQuestionDTO): Observable<boolean>;
    deleteQuizQuestion(quizQuestionId: number | undefined): Observable<boolean>;
    updateQuizQuestionAnswer(model: QuizQuestionAnswerDTO): Observable<boolean>;
    deleteQuizQuestionAnswer(quizAnswerId: number | undefined): Observable<boolean>;
    saveQuizQuestionAnswer(model: QuizQuestionAnswerDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class QuizQuestionClient implements IQuizQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createQuizQuestionList(questions: QuizQuestionDTO[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/CreateQuizQuestionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(questions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuizQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuizQuestionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateQuizQuestionList(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuizQuestionList(questions: QuizQuestionDTO[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/UpdateQuizQuestionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(questions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuizQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuizQuestionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateQuizQuestionList(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuizQuestion(model: QuizQuestionDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/UpdateQuizQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuizQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuizQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateQuizQuestion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuizQuestion(quizQuestionId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/DeleteQuizQuestion?";
        if (quizQuestionId === null)
            throw new Error("The parameter 'quizQuestionId' cannot be null.");
        else if (quizQuestionId !== undefined)
            url_ += "quizQuestionId=" + encodeURIComponent("" + quizQuestionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuizQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuizQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteQuizQuestion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuizQuestionAnswer(model: QuizQuestionAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/UpdateQuizQuestionAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuizQuestionAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuizQuestionAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateQuizQuestionAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuizQuestionAnswer(quizAnswerId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/DeleteQuizQuestionAnswer?";
        if (quizAnswerId === null)
            throw new Error("The parameter 'quizAnswerId' cannot be null.");
        else if (quizAnswerId !== undefined)
            url_ += "quizAnswerId=" + encodeURIComponent("" + quizAnswerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuizQuestionAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuizQuestionAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteQuizQuestionAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveQuizQuestionAnswer(model: QuizQuestionAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizQuestion/SaveQuizQuestionAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuizQuestionAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuizQuestionAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveQuizQuestionAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuizResultClient {
    saveQuizResult(model: QuizResultDTO): Observable<boolean>;
    checkQuizAndSaveResult(checkModel: QuizCheckModel): Observable<QuizResultDTO>;
    getQuizDataQuizResults(quizId: number | undefined): Observable<QuizDataQuizResultData>;
}

@Injectable({
    providedIn: 'root'
})
export class QuizResultClient implements IQuizResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveQuizResult(model: QuizResultDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/QuizResult/SaveQuizResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuizResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuizResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveQuizResult(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkQuizAndSaveResult(checkModel: QuizCheckModel): Observable<QuizResultDTO> {
        let url_ = this.baseUrl + "/api/LMS/QuizResult/CheckQuizAndSaveResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckQuizAndSaveResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckQuizAndSaveResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizResultDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizResultDTO>;
        }));
    }

    protected processCheckQuizAndSaveResult(response: HttpResponseBase): Observable<QuizResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizDataQuizResults(quizId: number | undefined): Observable<QuizDataQuizResultData> {
        let url_ = this.baseUrl + "/api/LMS/QuizResult/GetQuizDataQuizResults?";
        if (quizId === null)
            throw new Error("The parameter 'quizId' cannot be null.");
        else if (quizId !== undefined)
            url_ += "quizId=" + encodeURIComponent("" + quizId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizDataQuizResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizDataQuizResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizDataQuizResultData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizDataQuizResultData>;
        }));
    }

    protected processGetQuizDataQuizResults(response: HttpResponseBase): Observable<QuizDataQuizResultData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDataQuizResultData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IResultClient {
    getCourseResultList(tableMeta: TableMetaData): Observable<QueryResultOfCourseResult>;
    getLandingStatistics(): Observable<LandingStatisticsDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class ResultClient implements IResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCourseResultList(tableMeta: TableMetaData): Observable<QueryResultOfCourseResult> {
        let url_ = this.baseUrl + "/api/LMS/Result/GetCourseResultList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseResultList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseResultList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfCourseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfCourseResult>;
        }));
    }

    protected processGetCourseResultList(response: HttpResponseBase): Observable<QueryResultOfCourseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfCourseResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLandingStatistics(): Observable<LandingStatisticsDTO> {
        let url_ = this.baseUrl + "/api/LMS/Result/GetLandingStatistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLandingStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLandingStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LandingStatisticsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LandingStatisticsDTO>;
        }));
    }

    protected processGetLandingStatistics(response: HttpResponseBase): Observable<LandingStatisticsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LandingStatisticsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStaffClient {
    getPersonInfoFromGCP(request: GCPRequestData): Observable<PassportPersonInfoExt>;
    saveStaff(model: StaffDTO): Observable<number>;
    staffAddAndUpdate(model: StaffDTO): Observable<number>;
    saveUserIdToStaff(userStaff: UserStaff): Observable<boolean>;
    saveStaffFromGCP(model: GCPRequestData2): Observable<number>;
    changeStaffUserType(staffId: number): Observable<boolean>;
    addOrgIdToStaff(sendData: SendData): Observable<boolean>;
    staffById(id: number): Observable<StaffDTO>;
    getAllTeachers(tableMeta: TableMetaData): Observable<QueryResultOfStaffDTO>;
    getAllTrainers(tableMeta: TableMetaData): Observable<QueryResultOfStaffDTO>;
    getTeacherById(id: number | undefined): Observable<StaffDTO>;
    getTrinerById(id: number | undefined): Observable<StaffDTO>;
    enableAccess(staffId: number | undefined): Observable<boolean>;
    rejectionAccess(staffId: number | undefined, rejectionCommet: string | null | undefined): Observable<boolean>;
    addWorkInsAndPosToStaff(workInsitution: string | null | undefined, workPosition: string | null | undefined, staffId: number | undefined): Observable<boolean>;
    isStaffWorkInsAndPos(staffId: number | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class StaffClient implements IStaffClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPersonInfoFromGCP(request: GCPRequestData): Observable<PassportPersonInfoExt> {
        let url_ = this.baseUrl + "/api/LMS/Staff/getPersonInfoFromGCP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonInfoFromGCP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonInfoFromGCP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassportPersonInfoExt>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassportPersonInfoExt>;
        }));
    }

    protected processGetPersonInfoFromGCP(response: HttpResponseBase): Observable<PassportPersonInfoExt> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassportPersonInfoExt.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveStaff(model: StaffDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Staff/SaveStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveStaff(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    staffAddAndUpdate(model: StaffDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Staff/StaffAddAndUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStaffAddAndUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStaffAddAndUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processStaffAddAndUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveUserIdToStaff(userStaff: UserStaff): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/SaveUserIdToStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userStaff);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserIdToStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserIdToStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveUserIdToStaff(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveStaffFromGCP(model: GCPRequestData2): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Staff/SaveStaffFromGCP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStaffFromGCP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStaffFromGCP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveStaffFromGCP(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeStaffUserType(staffId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/ChangeStaffUserType/{staffId}";
        if (staffId === undefined || staffId === null)
            throw new Error("The parameter 'staffId' must be defined.");
        url_ = url_.replace("{staffId}", encodeURIComponent("" + staffId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStaffUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStaffUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangeStaffUserType(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addOrgIdToStaff(sendData: SendData): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/AddOrgIdToStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrgIdToStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrgIdToStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddOrgIdToStaff(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    staffById(id: number): Observable<StaffDTO> {
        let url_ = this.baseUrl + "/api/LMS/Staff/StaffById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStaffById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStaffById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDTO>;
        }));
    }

    protected processStaffById(response: HttpResponseBase): Observable<StaffDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTeachers(tableMeta: TableMetaData): Observable<QueryResultOfStaffDTO> {
        let url_ = this.baseUrl + "/api/LMS/Staff/GetAllTeachers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeachers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeachers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfStaffDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfStaffDTO>;
        }));
    }

    protected processGetAllTeachers(response: HttpResponseBase): Observable<QueryResultOfStaffDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfStaffDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTrainers(tableMeta: TableMetaData): Observable<QueryResultOfStaffDTO> {
        let url_ = this.baseUrl + "/api/LMS/Staff/GetAllTrainers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrainers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrainers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfStaffDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfStaffDTO>;
        }));
    }

    protected processGetAllTrainers(response: HttpResponseBase): Observable<QueryResultOfStaffDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfStaffDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTeacherById(id: number | undefined): Observable<StaffDTO> {
        let url_ = this.baseUrl + "/api/LMS/Staff/GetTeacherById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDTO>;
        }));
    }

    protected processGetTeacherById(response: HttpResponseBase): Observable<StaffDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTrinerById(id: number | undefined): Observable<StaffDTO> {
        let url_ = this.baseUrl + "/api/LMS/Staff/GetTrinerById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrinerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrinerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDTO>;
        }));
    }

    protected processGetTrinerById(response: HttpResponseBase): Observable<StaffDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enableAccess(staffId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/EnableAccess?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableAccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEnableAccess(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    rejectionAccess(staffId: number | undefined, rejectionCommet: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/RejectionAccess?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        if (rejectionCommet !== undefined && rejectionCommet !== null)
            url_ += "rejectionCommet=" + encodeURIComponent("" + rejectionCommet) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectionAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectionAccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRejectionAccess(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addWorkInsAndPosToStaff(workInsitution: string | null | undefined, workPosition: string | null | undefined, staffId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/AddWorkInsAndPosToStaff?";
        if (workInsitution !== undefined && workInsitution !== null)
            url_ += "workInsitution=" + encodeURIComponent("" + workInsitution) + "&";
        if (workPosition !== undefined && workPosition !== null)
            url_ += "workPosition=" + encodeURIComponent("" + workPosition) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWorkInsAndPosToStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWorkInsAndPosToStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddWorkInsAndPosToStaff(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isStaffWorkInsAndPos(staffId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Staff/IsStaffWorkInsAndPos?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsStaffWorkInsAndPos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsStaffWorkInsAndPos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsStaffWorkInsAndPos(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStatisticsClient {
    courseCountStatistics(): Observable<CourseCountStatisticDTO>;
    courseStatistics(tableMetaData: TableMetaData): Observable<QueryResultOfCourseStatisticsDTO>;
    getStatisticUserProgressByCourseId(tableMetaData: TableMetaData, courseId: number | undefined): Observable<ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString>;
    getStudentCreditAmount(filterData: CreditsSumModel): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class StatisticsClient implements IStatisticsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    courseCountStatistics(): Observable<CourseCountStatisticDTO> {
        let url_ = this.baseUrl + "/api/LMS/Statistics/CourseCountStatistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseCountStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseCountStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseCountStatisticDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseCountStatisticDTO>;
        }));
    }

    protected processCourseCountStatistics(response: HttpResponseBase): Observable<CourseCountStatisticDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseCountStatisticDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    courseStatistics(tableMetaData: TableMetaData): Observable<QueryResultOfCourseStatisticsDTO> {
        let url_ = this.baseUrl + "/api/LMS/Statistics/CourseStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfCourseStatisticsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfCourseStatisticsDTO>;
        }));
    }

    protected processCourseStatistics(response: HttpResponseBase): Observable<QueryResultOfCourseStatisticsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfCourseStatisticsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatisticUserProgressByCourseId(tableMetaData: TableMetaData, courseId: number | undefined): Observable<ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString> {
        let url_ = this.baseUrl + "/api/LMS/Statistics/GetStatisticUserProgressByCourseId?";
        if (courseId === null)
            throw new Error("The parameter 'courseId' cannot be null.");
        else if (courseId !== undefined)
            url_ += "courseId=" + encodeURIComponent("" + courseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatisticUserProgressByCourseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatisticUserProgressByCourseId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString>;
        }));
    }

    protected processGetStatisticUserProgressByCourseId(response: HttpResponseBase): Observable<ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStudentCreditAmount(filterData: CreditsSumModel): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/Statistics/GetStudentCreditAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentCreditAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentCreditAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetStudentCreditAmount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITestResultClient {
    saveTestResult(model: TestResultDTO): Observable<boolean>;
    getTestResultByStaffId(): Observable<TestResultDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class TestResultClient implements ITestResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveTestResult(model: TestResultDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/TestResult/SaveTestResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTestResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTestResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveTestResult(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTestResultByStaffId(): Observable<TestResultDTO> {
        let url_ = this.baseUrl + "/api/LMS/TestResult/GetTestResultByStaffId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestResultByStaffId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestResultByStaffId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestResultDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestResultDTO>;
        }));
    }

    protected processGetTestResultByStaffId(response: HttpResponseBase): Observable<TestResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITrainerTaskAnswerClient {
    saveTaskAnswer(model: TrainerTaskAnswerDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TrainerTaskAnswerClient implements ITrainerTaskAnswerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveTaskAnswer(model: TrainerTaskAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTaskAnswer/SaveTaskAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTaskAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTaskAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveTaskAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITrainerTaskClient {
    saveTrainerTask(model: TrainerTaskDTO): Observable<boolean>;
    getTrainerTaskById(id: number | undefined): Observable<TrainerTaskDTO>;
    getTrainerTaskId(id: number | undefined): Observable<TrainerTaskDTO>;
    getTaskIdAnswerScore(taskId: number | undefined, staffId: number | undefined): Observable<TrainerTaskDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class TrainerTaskClient implements ITrainerTaskClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveTrainerTask(model: TrainerTaskDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTask/SaveTrainerTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTrainerTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTrainerTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveTrainerTask(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTrainerTaskById(id: number | undefined): Observable<TrainerTaskDTO> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTask/GetTrainerTaskById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainerTaskById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainerTaskById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerTaskDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerTaskDTO>;
        }));
    }

    protected processGetTrainerTaskById(response: HttpResponseBase): Observable<TrainerTaskDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerTaskDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTrainerTaskId(id: number | undefined): Observable<TrainerTaskDTO> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTask/GetTrainerTaskId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainerTaskId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainerTaskId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerTaskDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerTaskDTO>;
        }));
    }

    protected processGetTrainerTaskId(response: HttpResponseBase): Observable<TrainerTaskDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerTaskDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTaskIdAnswerScore(taskId: number | undefined, staffId: number | undefined): Observable<TrainerTaskDTO> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTask/GetTaskIdAnswerScore?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskIdAnswerScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskIdAnswerScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerTaskDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerTaskDTO>;
        }));
    }

    protected processGetTaskIdAnswerScore(response: HttpResponseBase): Observable<TrainerTaskDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerTaskDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITrainerTaskScoreClient {
    saveTaskScore(model: TrainerTaskScoreDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class TrainerTaskScoreClient implements ITrainerTaskScoreClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveTaskScore(model: TrainerTaskScoreDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/TrainerTaskScore/SaveTaskScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTaskScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTaskScore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveTaskScore(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITranslationsClient {
    getTranslations(meta: TranslateMeta): Observable<KeyValuePairOfStringAndString[]>;
    addTranslation(translation: Translation): Observable<boolean>;
    getFullTranslations(meta: TableMetaData): Observable<TranslationsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TranslationsClient implements ITranslationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTranslations(meta: TranslateMeta): Observable<KeyValuePairOfStringAndString[]> {
        let url_ = this.baseUrl + "/api/LMS/Translations/GetTranslations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(meta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTranslations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTranslations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairOfStringAndString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairOfStringAndString[]>;
        }));
    }

    protected processGetTranslations(response: HttpResponseBase): Observable<KeyValuePairOfStringAndString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addTranslation(translation: Translation): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Translations/AddTranslation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(translation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTranslation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTranslation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddTranslation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFullTranslations(meta: TableMetaData): Observable<TranslationsDto> {
        let url_ = this.baseUrl + "/api/LMS/Translations/GetFullTranslations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(meta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullTranslations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullTranslations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TranslationsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TranslationsDto>;
        }));
    }

    protected processGetFullTranslations(response: HttpResponseBase): Observable<TranslationsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TranslationsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVideoClient {
    saveVideoContent(model: VideoContentDTO): Observable<boolean>;
    getAllVideoContent(lessonId: number | undefined): Observable<QueryResultOfVideoContentDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class VideoClient implements IVideoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveVideoContent(model: VideoContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/Video/SaveVideoContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveVideoContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVideoContent(lessonId: number | undefined): Observable<QueryResultOfVideoContentDTO> {
        let url_ = this.baseUrl + "/api/LMS/Video/GetAllVideoContent?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVideoContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVideoContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfVideoContentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfVideoContentDTO>;
        }));
    }

    protected processGetAllVideoContent(response: HttpResponseBase): Observable<QueryResultOfVideoContentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfVideoContentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVideoQuizAnswerClient {
    saveVideoQuizAnswer(model: VideoQuizAnswerDTO): Observable<number>;
    getVideoQuizAnswerById(id: number | undefined): Observable<VideoQuizAnswerDTO>;
    updateVideoQuizAnswer(model: VideoQuizAnswerDTO): Observable<boolean>;
    deleteVideoQuizAnswer(id: number | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class VideoQuizAnswerClient implements IVideoQuizAnswerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveVideoQuizAnswer(model: VideoQuizAnswerDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizAnswer/SaveVideoQuizAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoQuizAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoQuizAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveVideoQuizAnswer(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoQuizAnswerById(id: number | undefined): Observable<VideoQuizAnswerDTO> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizAnswer/GetVideoQuizAnswerById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoQuizAnswerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoQuizAnswerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VideoQuizAnswerDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VideoQuizAnswerDTO>;
        }));
    }

    protected processGetVideoQuizAnswerById(response: HttpResponseBase): Observable<VideoQuizAnswerDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoQuizAnswerDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVideoQuizAnswer(model: VideoQuizAnswerDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizAnswer/UpdateVideoQuizAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVideoQuizAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVideoQuizAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateVideoQuizAnswer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVideoQuizAnswer(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizAnswer/DeleteVideoQuizAnswer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVideoQuizAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVideoQuizAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteVideoQuizAnswer(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVideoQuizClient {
    saveVideoQuiz(model: VideoQuizDTO): Observable<number>;
    getVideoQuizById(id: number | undefined): Observable<VideoQuizDTO>;
    updateVideoQuiz(model: VideoQuizDTO): Observable<boolean>;
    deleteVideoQuiz(id: number | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class VideoQuizClient implements IVideoQuizClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveVideoQuiz(model: VideoQuizDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuiz/SaveVideoQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveVideoQuiz(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoQuizById(id: number | undefined): Observable<VideoQuizDTO> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuiz/GetVideoQuizById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoQuizById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoQuizById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VideoQuizDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VideoQuizDTO>;
        }));
    }

    protected processGetVideoQuizById(response: HttpResponseBase): Observable<VideoQuizDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoQuizDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVideoQuiz(model: VideoQuizDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuiz/UpdateVideoQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVideoQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVideoQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateVideoQuiz(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVideoQuiz(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuiz/DeleteVideoQuiz?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVideoQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVideoQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteVideoQuiz(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVideoQuizQuestionClient {
    saveVideoQuizQuestion(model: VideoQuizQuestionDTO): Observable<number>;
    getVideoQuizQuestionById(id: number | undefined): Observable<VideoQuizQuestionDTO>;
    updateVideoQuizQuestion(model: VideoQuizQuestionDTO): Observable<boolean>;
    deleteVideoQuizQuestion(id: number | undefined): Observable<FileResponse | null>;
    getAllVideoQuizQuestionByVideoQuizId(videoQuizId: number | undefined, quizCount: number | undefined): Observable<VideoQuizQuestionDTO[]>;
    saveVideoQuizQuestionList(models: VideoQuizQuestionDTO[]): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class VideoQuizQuestionClient implements IVideoQuizQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveVideoQuizQuestion(model: VideoQuizQuestionDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/SaveVideoQuizQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoQuizQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoQuizQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveVideoQuizQuestion(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoQuizQuestionById(id: number | undefined): Observable<VideoQuizQuestionDTO> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/GetVideoQuizQuestionById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoQuizQuestionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoQuizQuestionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VideoQuizQuestionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VideoQuizQuestionDTO>;
        }));
    }

    protected processGetVideoQuizQuestionById(response: HttpResponseBase): Observable<VideoQuizQuestionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoQuizQuestionDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVideoQuizQuestion(model: VideoQuizQuestionDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/UpdateVideoQuizQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVideoQuizQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVideoQuizQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateVideoQuizQuestion(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVideoQuizQuestion(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/DeleteVideoQuizQuestion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVideoQuizQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVideoQuizQuestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteVideoQuizQuestion(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVideoQuizQuestionByVideoQuizId(videoQuizId: number | undefined, quizCount: number | undefined): Observable<VideoQuizQuestionDTO[]> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/GetAllVideoQuizQuestionByVideoQuizId?";
        if (videoQuizId === null)
            throw new Error("The parameter 'videoQuizId' cannot be null.");
        else if (videoQuizId !== undefined)
            url_ += "videoQuizId=" + encodeURIComponent("" + videoQuizId) + "&";
        if (quizCount === null)
            throw new Error("The parameter 'quizCount' cannot be null.");
        else if (quizCount !== undefined)
            url_ += "quizCount=" + encodeURIComponent("" + quizCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVideoQuizQuestionByVideoQuizId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVideoQuizQuestionByVideoQuizId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VideoQuizQuestionDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VideoQuizQuestionDTO[]>;
        }));
    }

    protected processGetAllVideoQuizQuestionByVideoQuizId(response: HttpResponseBase): Observable<VideoQuizQuestionDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VideoQuizQuestionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveVideoQuizQuestionList(models: VideoQuizQuestionDTO[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/VideoQuizQuestion/SaveVideoQuizQuestionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoQuizQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoQuizQuestionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveVideoQuizQuestionList(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVideoTestClient {
    saveVideoTest(model: VideoTestDTO, moduleId: number | undefined): Observable<number>;
    getVideoTestById(id: number | undefined): Observable<VideoTestDTO>;
    updateVideoTest(model: VideoTestDTO): Observable<boolean>;
    deleteVideoTest(id: number | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class VideoTestClient implements IVideoTestClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveVideoTest(model: VideoTestDTO, moduleId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/LMS/VideoTest/SaveVideoTest?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveVideoTest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVideoTestById(id: number | undefined): Observable<VideoTestDTO> {
        let url_ = this.baseUrl + "/api/LMS/VideoTest/GetVideoTestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVideoTestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVideoTestById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VideoTestDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VideoTestDTO>;
        }));
    }

    protected processGetVideoTestById(response: HttpResponseBase): Observable<VideoTestDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoTestDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVideoTest(model: VideoTestDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/VideoTest/UpdateVideoTest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVideoTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVideoTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateVideoTest(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVideoTest(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LMS/VideoTest/DeleteVideoTest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVideoTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVideoTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteVideoTest(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWebContentClient {
    saveWebContent(model: WebContentDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class WebContentClient implements IWebContentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveWebContent(model: WebContentDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LMS/WebContent/SaveWebContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveWebContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveWebContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveWebContent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class QueryResultOfActionHistory implements IQueryResultOfActionHistory {
    totalItems!: number;
    items?: ActionHistory[] | undefined;

    constructor(data?: IQueryResultOfActionHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActionHistory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfActionHistory {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfActionHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfActionHistory {
    totalItems: number;
    items?: ActionHistory[] | undefined;
}

export class ActionHistory implements IActionHistory {
    id!: number;
    userId!: number;
    userFullName?: string | undefined;
    contentId!: number;
    contentName?: string | undefined;
    createdDate!: Date;
    actionType!: ActionType;
    status!: ActionHistoryStatus;
    orgId!: number;
    description?: string | undefined;

    constructor(data?: IActionHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userFullName = _data["userFullName"];
            this.contentId = _data["contentId"];
            this.contentName = _data["contentName"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.status = _data["status"];
            this.orgId = _data["orgId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ActionHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ActionHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userFullName"] = this.userFullName;
        data["contentId"] = this.contentId;
        data["contentName"] = this.contentName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["status"] = this.status;
        data["orgId"] = this.orgId;
        data["description"] = this.description;
        return data;
    }
}

export interface IActionHistory {
    id: number;
    userId: number;
    userFullName?: string | undefined;
    contentId: number;
    contentName?: string | undefined;
    createdDate: Date;
    actionType: ActionType;
    status: ActionHistoryStatus;
    orgId: number;
    description?: string | undefined;
}

export enum ActionType {
    Course = 10,
    Module = 20,
    Lesson = 30,
    Quiz = 40,
}

export enum ActionHistoryStatus {
    Create = 10,
    Read = 20,
    Update = 30,
    Delete = 40,
}

export class TableMetaData implements ITableMetaData {
    filters?: string | undefined;
    first!: number;
    rows!: number;
    sortField?: string | undefined;
    sortOrder!: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;

    constructor(data?: ITableMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"];
            this.first = _data["first"];
            this.rows = _data["rows"];
            this.sortField = _data["sortField"];
            this.sortOrder = _data["sortOrder"];
            this.filterHandle = _data["filterHandle"];
            this.tagHandle = _data["tagHandle"];
            this.globalFilter = _data["globalFilter"];
        }
    }

    static fromJS(data: any): TableMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters;
        data["first"] = this.first;
        data["rows"] = this.rows;
        data["sortField"] = this.sortField;
        data["sortOrder"] = this.sortOrder;
        data["filterHandle"] = this.filterHandle;
        data["tagHandle"] = this.tagHandle;
        data["globalFilter"] = this.globalFilter;
        return data;
    }
}

export interface ITableMetaData {
    filters?: string | undefined;
    first: number;
    rows: number;
    sortField?: string | undefined;
    sortOrder: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;
}

export class AudioDTO implements IAudioDTO {
    id!: number;
    lessonId!: number;
    fileAudioId!: string;
    title?: string | undefined;
    description?: string | undefined;
    audioWebUrl?: string | undefined;
    localUrl?: string | undefined;
    audioUploadType!: AudioUploadType;

    constructor(data?: IAudioDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.fileAudioId = _data["fileAudioId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.audioWebUrl = _data["audioWebUrl"];
            this.localUrl = _data["localUrl"];
            this.audioUploadType = _data["audioUploadType"];
        }
    }

    static fromJS(data: any): AudioDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AudioDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["fileAudioId"] = this.fileAudioId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["audioWebUrl"] = this.audioWebUrl;
        data["localUrl"] = this.localUrl;
        data["audioUploadType"] = this.audioUploadType;
        return data;
    }
}

export interface IAudioDTO {
    id: number;
    lessonId: number;
    fileAudioId: string;
    title?: string | undefined;
    description?: string | undefined;
    audioWebUrl?: string | undefined;
    localUrl?: string | undefined;
    audioUploadType: AudioUploadType;
}

export enum AudioUploadType {
    UseLink = 0,
    UseVoice = 1,
    UseFileContent = 2,
}

export enum CertificateType {
    Sanmin = 10,
    Uznada = 20,
    ItStudy = 30,
    General = 40,
}

export class CourseCertificateDTO implements ICourseCertificateDTO {
    id?: string | undefined;
    courseId!: number;
    staffId!: number;
    userId!: number;
    certificateSeria?: string | undefined;
    certificateNumber!: number;
    studentFullName?: string | undefined;
    studentWorkPlace?: string | undefined;
    studentPosition?: string | undefined;
    courseName?: string | undefined;
    givenTime!: Date;
    fullNameResponsible?: string | undefined;
    workPositionResponsible?: string | undefined;
    orgId?: number | undefined;
    certificateValidityPeriod?: Date | undefined;
    certificateFileName?: string | undefined;
    certificateType!: CertificateType;

    constructor(data?: ICourseCertificateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
            this.certificateSeria = _data["certificateSeria"];
            this.certificateNumber = _data["certificateNumber"];
            this.studentFullName = _data["studentFullName"];
            this.studentWorkPlace = _data["studentWorkPlace"];
            this.studentPosition = _data["studentPosition"];
            this.courseName = _data["courseName"];
            this.givenTime = _data["givenTime"] ? new Date(_data["givenTime"].toString()) : <any>undefined;
            this.fullNameResponsible = _data["fullNameResponsible"];
            this.workPositionResponsible = _data["workPositionResponsible"];
            this.orgId = _data["orgId"];
            this.certificateValidityPeriod = _data["certificateValidityPeriod"] ? new Date(_data["certificateValidityPeriod"].toString()) : <any>undefined;
            this.certificateFileName = _data["certificateFileName"];
            this.certificateType = _data["certificateType"];
        }
    }

    static fromJS(data: any): CourseCertificateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseCertificateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        data["certificateSeria"] = this.certificateSeria;
        data["certificateNumber"] = this.certificateNumber;
        data["studentFullName"] = this.studentFullName;
        data["studentWorkPlace"] = this.studentWorkPlace;
        data["studentPosition"] = this.studentPosition;
        data["courseName"] = this.courseName;
        data["givenTime"] = this.givenTime ? this.givenTime.toISOString() : <any>undefined;
        data["fullNameResponsible"] = this.fullNameResponsible;
        data["workPositionResponsible"] = this.workPositionResponsible;
        data["orgId"] = this.orgId;
        data["certificateValidityPeriod"] = this.certificateValidityPeriod ? this.certificateValidityPeriod.toISOString() : <any>undefined;
        data["certificateFileName"] = this.certificateFileName;
        data["certificateType"] = this.certificateType;
        return data;
    }
}

export interface ICourseCertificateDTO {
    id?: string | undefined;
    courseId: number;
    staffId: number;
    userId: number;
    certificateSeria?: string | undefined;
    certificateNumber: number;
    studentFullName?: string | undefined;
    studentWorkPlace?: string | undefined;
    studentPosition?: string | undefined;
    courseName?: string | undefined;
    givenTime: Date;
    fullNameResponsible?: string | undefined;
    workPositionResponsible?: string | undefined;
    orgId?: number | undefined;
    certificateValidityPeriod?: Date | undefined;
    certificateFileName?: string | undefined;
    certificateType: CertificateType;
}

export class ContactUsDTO implements IContactUsDTO {
    id?: number | undefined;
    fullName?: string | undefined;
    commentText?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    orgId?: number | undefined;
    userId?: number | undefined;
    status!: ContactUsStatus;

    constructor(data?: IContactUsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.commentText = _data["commentText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.orgId = _data["orgId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ContactUsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["commentText"] = this.commentText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["orgId"] = this.orgId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        return data;
    }
}

export interface IContactUsDTO {
    id?: number | undefined;
    fullName?: string | undefined;
    commentText?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    orgId?: number | undefined;
    userId?: number | undefined;
    status: ContactUsStatus;
}

export enum ContactUsStatus {
    New = 10,
    Answered = 20,
    Viewed = 30,
}

export class QueryResultOfContactUsDTO implements IQueryResultOfContactUsDTO {
    totalItems!: number;
    items?: ContactUsDTO[] | undefined;

    constructor(data?: IQueryResultOfContactUsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactUsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfContactUsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfContactUsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfContactUsDTO {
    totalItems: number;
    items?: ContactUsDTO[] | undefined;
}

export class ContentDTO implements IContentDTO {
    id!: number;
    lessonId!: number;
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: IContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

export interface IContentDTO {
    id: number;
    lessonId: number;
    title?: string | undefined;
    description?: string | undefined;
}

export class QueryResultOfContentDTO implements IQueryResultOfContentDTO {
    totalItems!: number;
    items?: ContentDTO[] | undefined;

    constructor(data?: IQueryResultOfContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfContentDTO {
    totalItems: number;
    items?: ContentDTO[] | undefined;
}

export class CourseDTO implements ICourseDTO {
    id?: number | undefined;
    courseStatus!: CourseStatus;
    courseStatusStr?: string | undefined;
    courseName?: string | undefined;
    description?: string | undefined;
    spCourseCategoryId!: number;
    spCourseTypeId!: number;
    codeForOrder?: number | undefined;
    imageFileId!: string;
    videoFileId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    registrationStartDate?: Date | undefined;
    registrationEndDate?: Date | undefined;
    isCertificate?: boolean | undefined;
    courseStudentsCount?: number | undefined;
    spCourseLanguageId!: number;
    spScienceDirectionId?: number | undefined;
    isPrice?: boolean | undefined;
    courseCredit?: number | undefined;
    spCourseTimeId?: number | undefined;
    spPaymentTypeId?: number | undefined;
    coursePrice?: number | undefined;
    courseNumberOfattempts?: number | undefined;
    attemptAdditionalTime?: number | undefined;
    spPaymentPeriodId?: number | undefined;
    periodPrice?: number | undefined;
    courseDuration!: number;
    spCourseDurationTypeId!: number;
    certificateFileId?: string | undefined;
    createdBy?: number | undefined;
    orgId?: number | undefined;
    certificateValidityPeriod?: number | undefined;
    modules?: ModuleDTO[] | undefined;
    trainerTasks?: TrainerTaskDTO[] | undefined;
    tests?: TestDTO[] | undefined;
    tbStaffJoinCourses?: TbStaffJoinCourse[] | undefined;

    constructor(data?: ICourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseStatus = _data["courseStatus"];
            this.courseStatusStr = _data["courseStatusStr"];
            this.courseName = _data["courseName"];
            this.description = _data["description"];
            this.spCourseCategoryId = _data["spCourseCategoryId"];
            this.spCourseTypeId = _data["spCourseTypeId"];
            this.codeForOrder = _data["codeForOrder"];
            this.imageFileId = _data["imageFileId"];
            this.videoFileId = _data["videoFileId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.registrationStartDate = _data["registrationStartDate"] ? new Date(_data["registrationStartDate"].toString()) : <any>undefined;
            this.registrationEndDate = _data["registrationEndDate"] ? new Date(_data["registrationEndDate"].toString()) : <any>undefined;
            this.isCertificate = _data["isCertificate"];
            this.courseStudentsCount = _data["courseStudentsCount"];
            this.spCourseLanguageId = _data["spCourseLanguageId"];
            this.spScienceDirectionId = _data["spScienceDirectionId"];
            this.isPrice = _data["isPrice"];
            this.courseCredit = _data["courseCredit"];
            this.spCourseTimeId = _data["spCourseTimeId"];
            this.spPaymentTypeId = _data["spPaymentTypeId"];
            this.coursePrice = _data["coursePrice"];
            this.courseNumberOfattempts = _data["courseNumberOfattempts"];
            this.attemptAdditionalTime = _data["attemptAdditionalTime"];
            this.spPaymentPeriodId = _data["spPaymentPeriodId"];
            this.periodPrice = _data["periodPrice"];
            this.courseDuration = _data["courseDuration"];
            this.spCourseDurationTypeId = _data["spCourseDurationTypeId"];
            this.certificateFileId = _data["certificateFileId"];
            this.createdBy = _data["createdBy"];
            this.orgId = _data["orgId"];
            this.certificateValidityPeriod = _data["certificateValidityPeriod"];
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ModuleDTO.fromJS(item));
            }
            if (Array.isArray(_data["trainerTasks"])) {
                this.trainerTasks = [] as any;
                for (let item of _data["trainerTasks"])
                    this.trainerTasks!.push(TrainerTaskDTO.fromJS(item));
            }
            if (Array.isArray(_data["tests"])) {
                this.tests = [] as any;
                for (let item of _data["tests"])
                    this.tests!.push(TestDTO.fromJS(item));
            }
            if (Array.isArray(_data["tbStaffJoinCourses"])) {
                this.tbStaffJoinCourses = [] as any;
                for (let item of _data["tbStaffJoinCourses"])
                    this.tbStaffJoinCourses!.push(TbStaffJoinCourse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseStatus"] = this.courseStatus;
        data["courseStatusStr"] = this.courseStatusStr;
        data["courseName"] = this.courseName;
        data["description"] = this.description;
        data["spCourseCategoryId"] = this.spCourseCategoryId;
        data["spCourseTypeId"] = this.spCourseTypeId;
        data["codeForOrder"] = this.codeForOrder;
        data["imageFileId"] = this.imageFileId;
        data["videoFileId"] = this.videoFileId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["registrationStartDate"] = this.registrationStartDate ? this.registrationStartDate.toISOString() : <any>undefined;
        data["registrationEndDate"] = this.registrationEndDate ? this.registrationEndDate.toISOString() : <any>undefined;
        data["isCertificate"] = this.isCertificate;
        data["courseStudentsCount"] = this.courseStudentsCount;
        data["spCourseLanguageId"] = this.spCourseLanguageId;
        data["spScienceDirectionId"] = this.spScienceDirectionId;
        data["isPrice"] = this.isPrice;
        data["courseCredit"] = this.courseCredit;
        data["spCourseTimeId"] = this.spCourseTimeId;
        data["spPaymentTypeId"] = this.spPaymentTypeId;
        data["coursePrice"] = this.coursePrice;
        data["courseNumberOfattempts"] = this.courseNumberOfattempts;
        data["attemptAdditionalTime"] = this.attemptAdditionalTime;
        data["spPaymentPeriodId"] = this.spPaymentPeriodId;
        data["periodPrice"] = this.periodPrice;
        data["courseDuration"] = this.courseDuration;
        data["spCourseDurationTypeId"] = this.spCourseDurationTypeId;
        data["certificateFileId"] = this.certificateFileId;
        data["createdBy"] = this.createdBy;
        data["orgId"] = this.orgId;
        data["certificateValidityPeriod"] = this.certificateValidityPeriod;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        if (Array.isArray(this.trainerTasks)) {
            data["trainerTasks"] = [];
            for (let item of this.trainerTasks)
                data["trainerTasks"].push(item.toJSON());
        }
        if (Array.isArray(this.tests)) {
            data["tests"] = [];
            for (let item of this.tests)
                data["tests"].push(item.toJSON());
        }
        if (Array.isArray(this.tbStaffJoinCourses)) {
            data["tbStaffJoinCourses"] = [];
            for (let item of this.tbStaffJoinCourses)
                data["tbStaffJoinCourses"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseDTO {
    id?: number | undefined;
    courseStatus: CourseStatus;
    courseStatusStr?: string | undefined;
    courseName?: string | undefined;
    description?: string | undefined;
    spCourseCategoryId: number;
    spCourseTypeId: number;
    codeForOrder?: number | undefined;
    imageFileId: string;
    videoFileId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    registrationStartDate?: Date | undefined;
    registrationEndDate?: Date | undefined;
    isCertificate?: boolean | undefined;
    courseStudentsCount?: number | undefined;
    spCourseLanguageId: number;
    spScienceDirectionId?: number | undefined;
    isPrice?: boolean | undefined;
    courseCredit?: number | undefined;
    spCourseTimeId?: number | undefined;
    spPaymentTypeId?: number | undefined;
    coursePrice?: number | undefined;
    courseNumberOfattempts?: number | undefined;
    attemptAdditionalTime?: number | undefined;
    spPaymentPeriodId?: number | undefined;
    periodPrice?: number | undefined;
    courseDuration: number;
    spCourseDurationTypeId: number;
    certificateFileId?: string | undefined;
    createdBy?: number | undefined;
    orgId?: number | undefined;
    certificateValidityPeriod?: number | undefined;
    modules?: ModuleDTO[] | undefined;
    trainerTasks?: TrainerTaskDTO[] | undefined;
    tests?: TestDTO[] | undefined;
    tbStaffJoinCourses?: TbStaffJoinCourse[] | undefined;
}

export enum CourseStatus {
    Draft = 0,
    PendingConfirmation = 1,
    Confirmed = 2,
    NotConfirmed = 3,
    Editing = 4,
    Published = 5,
}

export class ModuleDTO implements IModuleDTO {
    id?: number | undefined;
    courseId!: number;
    moduleName?: string | undefined;
    description?: string | undefined;
    codeForOrder!: number;
    moduleCredit?: number | undefined;
    allottedTime?: number | undefined;
    taskDiscussions?: TaskDiscussionDTO[] | undefined;
    peerReviews?: PeerReviewDTO[] | undefined;
    actionStatus!: ActionStatus;
    generalPartModules?: GeneralPartModule[] | undefined;

    constructor(data?: IModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.moduleName = _data["moduleName"];
            this.description = _data["description"];
            this.codeForOrder = _data["codeForOrder"];
            this.moduleCredit = _data["moduleCredit"];
            this.allottedTime = _data["allottedTime"];
            if (Array.isArray(_data["taskDiscussions"])) {
                this.taskDiscussions = [] as any;
                for (let item of _data["taskDiscussions"])
                    this.taskDiscussions!.push(TaskDiscussionDTO.fromJS(item));
            }
            if (Array.isArray(_data["peerReviews"])) {
                this.peerReviews = [] as any;
                for (let item of _data["peerReviews"])
                    this.peerReviews!.push(PeerReviewDTO.fromJS(item));
            }
            this.actionStatus = _data["actionStatus"];
            if (Array.isArray(_data["generalPartModules"])) {
                this.generalPartModules = [] as any;
                for (let item of _data["generalPartModules"])
                    this.generalPartModules!.push(GeneralPartModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["moduleName"] = this.moduleName;
        data["description"] = this.description;
        data["codeForOrder"] = this.codeForOrder;
        data["moduleCredit"] = this.moduleCredit;
        data["allottedTime"] = this.allottedTime;
        if (Array.isArray(this.taskDiscussions)) {
            data["taskDiscussions"] = [];
            for (let item of this.taskDiscussions)
                data["taskDiscussions"].push(item.toJSON());
        }
        if (Array.isArray(this.peerReviews)) {
            data["peerReviews"] = [];
            for (let item of this.peerReviews)
                data["peerReviews"].push(item.toJSON());
        }
        data["actionStatus"] = this.actionStatus;
        if (Array.isArray(this.generalPartModules)) {
            data["generalPartModules"] = [];
            for (let item of this.generalPartModules)
                data["generalPartModules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModuleDTO {
    id?: number | undefined;
    courseId: number;
    moduleName?: string | undefined;
    description?: string | undefined;
    codeForOrder: number;
    moduleCredit?: number | undefined;
    allottedTime?: number | undefined;
    taskDiscussions?: TaskDiscussionDTO[] | undefined;
    peerReviews?: PeerReviewDTO[] | undefined;
    actionStatus: ActionStatus;
    generalPartModules?: GeneralPartModule[] | undefined;
}

export class TaskDiscussionDTO implements ITaskDiscussionDTO {
    id?: number | undefined;
    moduleId?: number | undefined;
    discussionTheme?: string | undefined;
    description?: string | undefined;
    postMust!: boolean;
    answers?: TaskDiscussionAnswer[] | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    actionStatus!: ActionStatus;

    constructor(data?: ITaskDiscussionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.discussionTheme = _data["discussionTheme"];
            this.description = _data["description"];
            this.postMust = _data["postMust"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(TaskDiscussionAnswer.fromJS(item));
            }
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
            this.actionStatus = _data["actionStatus"];
        }
    }

    static fromJS(data: any): TaskDiscussionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDiscussionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["discussionTheme"] = this.discussionTheme;
        data["description"] = this.description;
        data["postMust"] = this.postMust;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        data["actionStatus"] = this.actionStatus;
        return data;
    }
}

export interface ITaskDiscussionDTO {
    id?: number | undefined;
    moduleId?: number | undefined;
    discussionTheme?: string | undefined;
    description?: string | undefined;
    postMust: boolean;
    answers?: TaskDiscussionAnswer[] | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    actionStatus: ActionStatus;
}

export abstract class EntityBase implements IEntityBase {
    id!: number;
    active!: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;

    constructor(data?: IEntityBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.active = _data["active"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["active"] = this.active;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEntityBase {
    id: number;
    active: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;
}

export class TaskDiscussionAnswer extends EntityBase implements ITaskDiscussionAnswer {
    staffId?: number | undefined;
    taskDiscussionId?: number | undefined;
    textAnswer?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    videoFileId?: string | undefined;
    audioFileId?: string | undefined;

    constructor(data?: ITaskDiscussionAnswer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.staffId = _data["staffId"];
            this.taskDiscussionId = _data["taskDiscussionId"];
            this.textAnswer = _data["textAnswer"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.videoFileId = _data["videoFileId"];
            this.audioFileId = _data["audioFileId"];
        }
    }

    static override fromJS(data: any): TaskDiscussionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDiscussionAnswer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["taskDiscussionId"] = this.taskDiscussionId;
        data["textAnswer"] = this.textAnswer;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["videoFileId"] = this.videoFileId;
        data["audioFileId"] = this.audioFileId;
        super.toJSON(data);
        return data;
    }
}

export interface ITaskDiscussionAnswer extends IEntityBase {
    staffId?: number | undefined;
    taskDiscussionId?: number | undefined;
    textAnswer?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    videoFileId?: string | undefined;
    audioFileId?: string | undefined;
}

export enum ActionStatus {
    Closed = 0,
    Opened = 1,
    Continues = 2,
    Finished = 3,
}

export class PeerReviewDTO implements IPeerReviewDTO {
    id?: number | undefined;
    moduleId!: number;
    taskName?: string | undefined;
    taskDetail?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    actionStatus!: ActionStatus;

    constructor(data?: IPeerReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.taskName = _data["taskName"];
            this.taskDetail = _data["taskDetail"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
            this.actionStatus = _data["actionStatus"];
        }
    }

    static fromJS(data: any): PeerReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PeerReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["taskName"] = this.taskName;
        data["taskDetail"] = this.taskDetail;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        data["actionStatus"] = this.actionStatus;
        return data;
    }
}

export interface IPeerReviewDTO {
    id?: number | undefined;
    moduleId: number;
    taskName?: string | undefined;
    taskDetail?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    actionStatus: ActionStatus;
}

export class GeneralPartModule extends EntityBase implements IGeneralPartModule {
    moduleId!: number;
    codeForOrder!: number;
    generalPartType!: GeneralPartType;
    lesson?: Lesson | undefined;
    quiz?: Quiz | undefined;
    videoTest?: VideoTest | undefined;

    constructor(data?: IGeneralPartModule) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.codeForOrder = _data["codeForOrder"];
            this.generalPartType = _data["generalPartType"];
            this.lesson = _data["lesson"] ? Lesson.fromJS(_data["lesson"]) : <any>undefined;
            this.quiz = _data["quiz"] ? Quiz.fromJS(_data["quiz"]) : <any>undefined;
            this.videoTest = _data["videoTest"] ? VideoTest.fromJS(_data["videoTest"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): GeneralPartModule {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralPartModule();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["codeForOrder"] = this.codeForOrder;
        data["generalPartType"] = this.generalPartType;
        data["lesson"] = this.lesson ? this.lesson.toJSON() : <any>undefined;
        data["quiz"] = this.quiz ? this.quiz.toJSON() : <any>undefined;
        data["videoTest"] = this.videoTest ? this.videoTest.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IGeneralPartModule extends IEntityBase {
    moduleId: number;
    codeForOrder: number;
    generalPartType: GeneralPartType;
    lesson?: Lesson | undefined;
    quiz?: Quiz | undefined;
    videoTest?: VideoTest | undefined;
}

export enum GeneralPartType {
    Lesson = 10,
    Quiz = 20,
    VideoTest = 30,
}

export class Lesson extends EntityBase implements ILesson {
    generalPartModuleId!: number;
    lessonName?: string | undefined;
    description?: string | undefined;
    codeForOrder?: number | undefined;
    imageFileId?: string | undefined;
    actionStatus?: ActionStatus | undefined;
    generalContents?: GeneralContent[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;

    constructor(data?: ILesson) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.lessonName = _data["lessonName"];
            this.description = _data["description"];
            this.codeForOrder = _data["codeForOrder"];
            this.imageFileId = _data["imageFileId"];
            this.actionStatus = _data["actionStatus"];
            if (Array.isArray(_data["generalContents"])) {
                this.generalContents = [] as any;
                for (let item of _data["generalContents"])
                    this.generalContents!.push(GeneralContent.fromJS(item));
            }
            this.generalPartModule = _data["generalPartModule"] ? GeneralPartModule.fromJS(_data["generalPartModule"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Lesson {
        data = typeof data === 'object' ? data : {};
        let result = new Lesson();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["lessonName"] = this.lessonName;
        data["description"] = this.description;
        data["codeForOrder"] = this.codeForOrder;
        data["imageFileId"] = this.imageFileId;
        data["actionStatus"] = this.actionStatus;
        if (Array.isArray(this.generalContents)) {
            data["generalContents"] = [];
            for (let item of this.generalContents)
                data["generalContents"].push(item.toJSON());
        }
        data["generalPartModule"] = this.generalPartModule ? this.generalPartModule.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ILesson extends IEntityBase {
    generalPartModuleId: number;
    lessonName?: string | undefined;
    description?: string | undefined;
    codeForOrder?: number | undefined;
    imageFileId?: string | undefined;
    actionStatus?: ActionStatus | undefined;
    generalContents?: GeneralContent[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;
}

export class GeneralContent extends EntityBase implements IGeneralContent {
    lessonId!: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId?: string | undefined;
    audioUploadType?: AudioUploadType | undefined;
    fileDocumentId?: string | undefined;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId?: string | undefined;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId?: string | undefined;
    videoUploadType?: VideoUploadType | undefined;
    typeGeneralContent?: TypeGeneralContent | undefined;
    codeForOrder!: number;
    actionStatus!: ActionStatus;
    fileNameStr?: string | undefined;

    constructor(data?: IGeneralContent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lessonId = _data["lessonId"];
            this.sectionNumber = _data["sectionNumber"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.fileAudioId = _data["fileAudioId"];
            this.audioUploadType = _data["audioUploadType"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.fileType = _data["fileType"];
            this.fileSize = _data["fileSize"];
            this.fileImageId = _data["fileImageId"];
            this.youTubeUrl = _data["youTubeUrl"];
            this.webUrl = _data["webUrl"];
            this.localUrl = _data["localUrl"];
            this.fileVideoId = _data["fileVideoId"];
            this.videoUploadType = _data["videoUploadType"];
            this.typeGeneralContent = _data["typeGeneralContent"];
            this.codeForOrder = _data["codeForOrder"];
            this.actionStatus = _data["actionStatus"];
            this.fileNameStr = _data["fileNameStr"];
        }
    }

    static override fromJS(data: any): GeneralContent {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lessonId"] = this.lessonId;
        data["sectionNumber"] = this.sectionNumber;
        data["title"] = this.title;
        data["description"] = this.description;
        data["fileAudioId"] = this.fileAudioId;
        data["audioUploadType"] = this.audioUploadType;
        data["fileDocumentId"] = this.fileDocumentId;
        data["fileType"] = this.fileType;
        data["fileSize"] = this.fileSize;
        data["fileImageId"] = this.fileImageId;
        data["youTubeUrl"] = this.youTubeUrl;
        data["webUrl"] = this.webUrl;
        data["localUrl"] = this.localUrl;
        data["fileVideoId"] = this.fileVideoId;
        data["videoUploadType"] = this.videoUploadType;
        data["typeGeneralContent"] = this.typeGeneralContent;
        data["codeForOrder"] = this.codeForOrder;
        data["actionStatus"] = this.actionStatus;
        data["fileNameStr"] = this.fileNameStr;
        super.toJSON(data);
        return data;
    }
}

export interface IGeneralContent extends IEntityBase {
    lessonId: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId?: string | undefined;
    audioUploadType?: AudioUploadType | undefined;
    fileDocumentId?: string | undefined;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId?: string | undefined;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId?: string | undefined;
    videoUploadType?: VideoUploadType | undefined;
    typeGeneralContent?: TypeGeneralContent | undefined;
    codeForOrder: number;
    actionStatus: ActionStatus;
    fileNameStr?: string | undefined;
}

export enum VideoUploadType {
    UseLink = 0,
    UseFileContent = 1,
    UseUTubeLink = 2,
}

export enum TypeGeneralContent {
    Content = 0,
    Document = 1,
    Video = 2,
    Photo = 3,
    Audio = 4,
    WebContent = 5,
    IFrame = 6,
}

export class Quiz extends EntityBase implements IQuiz {
    courseId?: number | undefined;
    generalPartModuleId?: number | undefined;
    quizName?: string | undefined;
    spQuizTimeId!: number;
    quizTime!: number;
    maxScore!: number;
    numberOfQuiz!: number;
    passingScore!: number;
    numberAttempts!: number;
    isShowRihgtAnswer!: boolean;
    isBackQuestion!: boolean;
    deadline?: Date | undefined;
    quizType!: QuizType;
    quizLevelQuestions?: QuizLevelQuestion[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;

    constructor(data?: IQuiz) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.courseId = _data["courseId"];
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.quizName = _data["quizName"];
            this.spQuizTimeId = _data["spQuizTimeId"];
            this.quizTime = _data["quizTime"];
            this.maxScore = _data["maxScore"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.passingScore = _data["passingScore"];
            this.numberAttempts = _data["numberAttempts"];
            this.isShowRihgtAnswer = _data["isShowRihgtAnswer"];
            this.isBackQuestion = _data["isBackQuestion"];
            this.deadline = _data["deadline"] ? new Date(_data["deadline"].toString()) : <any>undefined;
            this.quizType = _data["quizType"];
            if (Array.isArray(_data["quizLevelQuestions"])) {
                this.quizLevelQuestions = [] as any;
                for (let item of _data["quizLevelQuestions"])
                    this.quizLevelQuestions!.push(QuizLevelQuestion.fromJS(item));
            }
            this.generalPartModule = _data["generalPartModule"] ? GeneralPartModule.fromJS(_data["generalPartModule"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Quiz {
        data = typeof data === 'object' ? data : {};
        let result = new Quiz();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["quizName"] = this.quizName;
        data["spQuizTimeId"] = this.spQuizTimeId;
        data["quizTime"] = this.quizTime;
        data["maxScore"] = this.maxScore;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["passingScore"] = this.passingScore;
        data["numberAttempts"] = this.numberAttempts;
        data["isShowRihgtAnswer"] = this.isShowRihgtAnswer;
        data["isBackQuestion"] = this.isBackQuestion;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["quizType"] = this.quizType;
        if (Array.isArray(this.quizLevelQuestions)) {
            data["quizLevelQuestions"] = [];
            for (let item of this.quizLevelQuestions)
                data["quizLevelQuestions"].push(item.toJSON());
        }
        data["generalPartModule"] = this.generalPartModule ? this.generalPartModule.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuiz extends IEntityBase {
    courseId?: number | undefined;
    generalPartModuleId?: number | undefined;
    quizName?: string | undefined;
    spQuizTimeId: number;
    quizTime: number;
    maxScore: number;
    numberOfQuiz: number;
    passingScore: number;
    numberAttempts: number;
    isShowRihgtAnswer: boolean;
    isBackQuestion: boolean;
    deadline?: Date | undefined;
    quizType: QuizType;
    quizLevelQuestions?: QuizLevelQuestion[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;
}

export enum QuizType {
    SimpleQuiz = 10,
    ModulFinalQuiz = 20,
    CourseIntialQuiz = 30,
    CourseFinalQuiz = 40,
    VideoQuiz = 50,
}

export class QuizLevelQuestion extends EntityBase implements IQuizLevelQuestion {
    quizId!: number;
    levelQuestionName?: string | undefined;
    numberOfQuizLevel!: number;
    quizQuestionCategories?: QuizQuestionCategory[] | undefined;

    constructor(data?: IQuizLevelQuestion) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quizId = _data["quizId"];
            this.levelQuestionName = _data["levelQuestionName"];
            this.numberOfQuizLevel = _data["numberOfQuizLevel"];
            if (Array.isArray(_data["quizQuestionCategories"])) {
                this.quizQuestionCategories = [] as any;
                for (let item of _data["quizQuestionCategories"])
                    this.quizQuestionCategories!.push(QuizQuestionCategory.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizLevelQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new QuizLevelQuestion();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["levelQuestionName"] = this.levelQuestionName;
        data["numberOfQuizLevel"] = this.numberOfQuizLevel;
        if (Array.isArray(this.quizQuestionCategories)) {
            data["quizQuestionCategories"] = [];
            for (let item of this.quizQuestionCategories)
                data["quizQuestionCategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizLevelQuestion extends IEntityBase {
    quizId: number;
    levelQuestionName?: string | undefined;
    numberOfQuizLevel: number;
    quizQuestionCategories?: QuizQuestionCategory[] | undefined;
}

export class QuizQuestionCategory extends EntityBase implements IQuizQuestionCategory {
    quizLevelQuestionId!: number;
    spQuizQuestionCategoryId!: number;
    numberOfQuizQuestion!: number;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestions?: QuizQuestion[] | undefined;

    constructor(data?: IQuizQuestionCategory) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quizLevelQuestionId = _data["quizLevelQuestionId"];
            this.spQuizQuestionCategoryId = _data["spQuizQuestionCategoryId"];
            this.numberOfQuizQuestion = _data["numberOfQuizQuestion"];
            this.quizQuestionType = _data["quizQuestionType"];
            if (Array.isArray(_data["quizQuestions"])) {
                this.quizQuestions = [] as any;
                for (let item of _data["quizQuestions"])
                    this.quizQuestions!.push(QuizQuestion.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizQuestionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionCategory();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizLevelQuestionId"] = this.quizLevelQuestionId;
        data["spQuizQuestionCategoryId"] = this.spQuizQuestionCategoryId;
        data["numberOfQuizQuestion"] = this.numberOfQuizQuestion;
        data["quizQuestionType"] = this.quizQuestionType;
        if (Array.isArray(this.quizQuestions)) {
            data["quizQuestions"] = [];
            for (let item of this.quizQuestions)
                data["quizQuestions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizQuestionCategory extends IEntityBase {
    quizLevelQuestionId: number;
    spQuizQuestionCategoryId: number;
    numberOfQuizQuestion: number;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestions?: QuizQuestion[] | undefined;
}

export enum QuizQuestionType {
    SingleChoice = 10,
    MultipleChoice = 20,
    Matching = 30,
}

export class QuizQuestion extends EntityBase implements IQuizQuestion {
    quizQuestionCategoryId!: number;
    quizQuestionText?: string | undefined;
    imageFileId?: string | undefined;
    isMultiple?: boolean | undefined;
    quizQuestionType!: QuizQuestionType;
    quizQuestionAnswers?: QuizQuestionAnswer[] | undefined;

    constructor(data?: IQuizQuestion) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quizQuestionCategoryId = _data["quizQuestionCategoryId"];
            this.quizQuestionText = _data["quizQuestionText"];
            this.imageFileId = _data["imageFileId"];
            this.isMultiple = _data["isMultiple"];
            this.quizQuestionType = _data["quizQuestionType"];
            if (Array.isArray(_data["quizQuestionAnswers"])) {
                this.quizQuestionAnswers = [] as any;
                for (let item of _data["quizQuestionAnswers"])
                    this.quizQuestionAnswers!.push(QuizQuestionAnswer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestion();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizQuestionCategoryId"] = this.quizQuestionCategoryId;
        data["quizQuestionText"] = this.quizQuestionText;
        data["imageFileId"] = this.imageFileId;
        data["isMultiple"] = this.isMultiple;
        data["quizQuestionType"] = this.quizQuestionType;
        if (Array.isArray(this.quizQuestionAnswers)) {
            data["quizQuestionAnswers"] = [];
            for (let item of this.quizQuestionAnswers)
                data["quizQuestionAnswers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizQuestion extends IEntityBase {
    quizQuestionCategoryId: number;
    quizQuestionText?: string | undefined;
    imageFileId?: string | undefined;
    isMultiple?: boolean | undefined;
    quizQuestionType: QuizQuestionType;
    quizQuestionAnswers?: QuizQuestionAnswer[] | undefined;
}

export class QuizQuestionAnswer extends EntityBase implements IQuizQuestionAnswer {
    quizQuestionId!: number;
    answerText?: string | undefined;
    answerTextMatch?: string | undefined;
    isRight?: boolean | undefined;
    imageFileId?: string | undefined;

    constructor(data?: IQuizQuestionAnswer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quizQuestionId = _data["quizQuestionId"];
            this.answerText = _data["answerText"];
            this.answerTextMatch = _data["answerTextMatch"];
            this.isRight = _data["isRight"];
            this.imageFileId = _data["imageFileId"];
        }
    }

    static override fromJS(data: any): QuizQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionAnswer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizQuestionId"] = this.quizQuestionId;
        data["answerText"] = this.answerText;
        data["answerTextMatch"] = this.answerTextMatch;
        data["isRight"] = this.isRight;
        data["imageFileId"] = this.imageFileId;
        super.toJSON(data);
        return data;
    }
}

export interface IQuizQuestionAnswer extends IEntityBase {
    quizQuestionId: number;
    answerText?: string | undefined;
    answerTextMatch?: string | undefined;
    isRight?: boolean | undefined;
    imageFileId?: string | undefined;
}

export class VideoTest extends EntityBase implements IVideoTest {
    generalPartModuleId!: number;
    videoTestName?: string | undefined;
    description?: string | undefined;
    videoFileId!: string;
    videoQuizzes?: VideoQuiz[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;

    constructor(data?: IVideoTest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.videoTestName = _data["videoTestName"];
            this.description = _data["description"];
            this.videoFileId = _data["videoFileId"];
            if (Array.isArray(_data["videoQuizzes"])) {
                this.videoQuizzes = [] as any;
                for (let item of _data["videoQuizzes"])
                    this.videoQuizzes!.push(VideoQuiz.fromJS(item));
            }
            this.generalPartModule = _data["generalPartModule"] ? GeneralPartModule.fromJS(_data["generalPartModule"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): VideoTest {
        data = typeof data === 'object' ? data : {};
        let result = new VideoTest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["videoTestName"] = this.videoTestName;
        data["description"] = this.description;
        data["videoFileId"] = this.videoFileId;
        if (Array.isArray(this.videoQuizzes)) {
            data["videoQuizzes"] = [];
            for (let item of this.videoQuizzes)
                data["videoQuizzes"].push(item.toJSON());
        }
        data["generalPartModule"] = this.generalPartModule ? this.generalPartModule.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IVideoTest extends IEntityBase {
    generalPartModuleId: number;
    videoTestName?: string | undefined;
    description?: string | undefined;
    videoFileId: string;
    videoQuizzes?: VideoQuiz[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;
}

export class VideoQuiz extends EntityBase implements IVideoQuiz {
    videoTestId!: number;
    timeCode!: number;
    quizTime!: number;
    maxScore?: number | undefined;
    passingScore?: number | undefined;
    numberOfQuiz!: number;
    numberAttempts!: number;
    timeLimit!: boolean;
    repeatIfWrong!: boolean;
    showCorrectAnswer!: boolean;
    quizQuestions?: VideoQuizQuestion[] | undefined;

    constructor(data?: IVideoQuiz) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.videoTestId = _data["videoTestId"];
            this.timeCode = _data["timeCode"];
            this.quizTime = _data["quizTime"];
            this.maxScore = _data["maxScore"];
            this.passingScore = _data["passingScore"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.numberAttempts = _data["numberAttempts"];
            this.timeLimit = _data["timeLimit"];
            this.repeatIfWrong = _data["repeatIfWrong"];
            this.showCorrectAnswer = _data["showCorrectAnswer"];
            if (Array.isArray(_data["quizQuestions"])) {
                this.quizQuestions = [] as any;
                for (let item of _data["quizQuestions"])
                    this.quizQuestions!.push(VideoQuizQuestion.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): VideoQuiz {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuiz();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["videoTestId"] = this.videoTestId;
        data["timeCode"] = this.timeCode;
        data["quizTime"] = this.quizTime;
        data["maxScore"] = this.maxScore;
        data["passingScore"] = this.passingScore;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["numberAttempts"] = this.numberAttempts;
        data["timeLimit"] = this.timeLimit;
        data["repeatIfWrong"] = this.repeatIfWrong;
        data["showCorrectAnswer"] = this.showCorrectAnswer;
        if (Array.isArray(this.quizQuestions)) {
            data["quizQuestions"] = [];
            for (let item of this.quizQuestions)
                data["quizQuestions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVideoQuiz extends IEntityBase {
    videoTestId: number;
    timeCode: number;
    quizTime: number;
    maxScore?: number | undefined;
    passingScore?: number | undefined;
    numberOfQuiz: number;
    numberAttempts: number;
    timeLimit: boolean;
    repeatIfWrong: boolean;
    showCorrectAnswer: boolean;
    quizQuestions?: VideoQuizQuestion[] | undefined;
}

export class VideoQuizQuestion extends EntityBase implements IVideoQuizQuestion {
    videoQuizId!: number;
    questionText?: string | undefined;
    questionAnswer?: VideoQuizAnswer[] | undefined;

    constructor(data?: IVideoQuizQuestion) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.videoQuizId = _data["videoQuizId"];
            this.questionText = _data["questionText"];
            if (Array.isArray(_data["questionAnswer"])) {
                this.questionAnswer = [] as any;
                for (let item of _data["questionAnswer"])
                    this.questionAnswer!.push(VideoQuizAnswer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): VideoQuizQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuizQuestion();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["videoQuizId"] = this.videoQuizId;
        data["questionText"] = this.questionText;
        if (Array.isArray(this.questionAnswer)) {
            data["questionAnswer"] = [];
            for (let item of this.questionAnswer)
                data["questionAnswer"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVideoQuizQuestion extends IEntityBase {
    videoQuizId: number;
    questionText?: string | undefined;
    questionAnswer?: VideoQuizAnswer[] | undefined;
}

export class VideoQuizAnswer extends EntityBase implements IVideoQuizAnswer {
    videoQuizQuestionId!: number;
    answerText?: string | undefined;
    isRight!: boolean;

    constructor(data?: IVideoQuizAnswer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.videoQuizQuestionId = _data["videoQuizQuestionId"];
            this.answerText = _data["answerText"];
            this.isRight = _data["isRight"];
        }
    }

    static override fromJS(data: any): VideoQuizAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuizAnswer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["videoQuizQuestionId"] = this.videoQuizQuestionId;
        data["answerText"] = this.answerText;
        data["isRight"] = this.isRight;
        super.toJSON(data);
        return data;
    }
}

export interface IVideoQuizAnswer extends IEntityBase {
    videoQuizQuestionId: number;
    answerText?: string | undefined;
    isRight: boolean;
}

export class TrainerTaskDTO implements ITrainerTaskDTO {
    id?: number | undefined;
    courseId!: number;
    taskName?: string | undefined;
    description?: string | undefined;
    maxScore!: number;
    taskDeadline!: Date;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    codeForOrder!: number;
    actionStatus!: ActionStatus;
    trainerTaskAnswers?: TrainerTaskAnswer[] | undefined;

    constructor(data?: ITrainerTaskDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.taskName = _data["taskName"];
            this.description = _data["description"];
            this.maxScore = _data["maxScore"];
            this.taskDeadline = _data["taskDeadline"] ? new Date(_data["taskDeadline"].toString()) : <any>undefined;
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
            this.codeForOrder = _data["codeForOrder"];
            this.actionStatus = _data["actionStatus"];
            if (Array.isArray(_data["trainerTaskAnswers"])) {
                this.trainerTaskAnswers = [] as any;
                for (let item of _data["trainerTaskAnswers"])
                    this.trainerTaskAnswers!.push(TrainerTaskAnswer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerTaskDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerTaskDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["taskName"] = this.taskName;
        data["description"] = this.description;
        data["maxScore"] = this.maxScore;
        data["taskDeadline"] = this.taskDeadline ? this.taskDeadline.toISOString() : <any>undefined;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        data["codeForOrder"] = this.codeForOrder;
        data["actionStatus"] = this.actionStatus;
        if (Array.isArray(this.trainerTaskAnswers)) {
            data["trainerTaskAnswers"] = [];
            for (let item of this.trainerTaskAnswers)
                data["trainerTaskAnswers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerTaskDTO {
    id?: number | undefined;
    courseId: number;
    taskName?: string | undefined;
    description?: string | undefined;
    maxScore: number;
    taskDeadline: Date;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    codeForOrder: number;
    actionStatus: ActionStatus;
    trainerTaskAnswers?: TrainerTaskAnswer[] | undefined;
}

export class TrainerTaskAnswer extends EntityBase implements ITrainerTaskAnswer {
    trainerTaskId!: number;
    staffId!: number;
    textAnswer?: string | undefined;
    status!: TrainerTaskAnswerStatus;
    taskScore?: TrainerTaskScore | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;

    constructor(data?: ITrainerTaskAnswer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trainerTaskId = _data["trainerTaskId"];
            this.staffId = _data["staffId"];
            this.textAnswer = _data["textAnswer"];
            this.status = _data["status"];
            this.taskScore = _data["taskScore"] ? TrainerTaskScore.fromJS(_data["taskScore"]) : <any>undefined;
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
        }
    }

    static override fromJS(data: any): TrainerTaskAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerTaskAnswer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerTaskId"] = this.trainerTaskId;
        data["staffId"] = this.staffId;
        data["textAnswer"] = this.textAnswer;
        data["status"] = this.status;
        data["taskScore"] = this.taskScore ? this.taskScore.toJSON() : <any>undefined;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        super.toJSON(data);
        return data;
    }
}

export interface ITrainerTaskAnswer extends IEntityBase {
    trainerTaskId: number;
    staffId: number;
    textAnswer?: string | undefined;
    status: TrainerTaskAnswerStatus;
    taskScore?: TrainerTaskScore | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
}

export enum TrainerTaskAnswerStatus {
    New = 0,
    Checked = 1,
}

export class TrainerTaskScore extends EntityBase implements ITrainerTaskScore {
    trainerTaskAnswerId!: number;
    comment?: string | undefined;
    score!: number;
    trainerTaskAnswer?: TrainerTaskAnswer | undefined;

    constructor(data?: ITrainerTaskScore) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trainerTaskAnswerId = _data["trainerTaskAnswerId"];
            this.comment = _data["comment"];
            this.score = _data["score"];
            this.trainerTaskAnswer = _data["trainerTaskAnswer"] ? TrainerTaskAnswer.fromJS(_data["trainerTaskAnswer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TrainerTaskScore {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerTaskScore();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerTaskAnswerId"] = this.trainerTaskAnswerId;
        data["comment"] = this.comment;
        data["score"] = this.score;
        data["trainerTaskAnswer"] = this.trainerTaskAnswer ? this.trainerTaskAnswer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ITrainerTaskScore extends IEntityBase {
    trainerTaskAnswerId: number;
    comment?: string | undefined;
    score: number;
    trainerTaskAnswer?: TrainerTaskAnswer | undefined;
}

export class TestDTO implements ITestDTO {
    id?: number | undefined;
    courseId!: number;
    tastName?: string | undefined;
    description?: string | undefined;
    spTestTypeId!: number;
    showResults!: boolean;
    numberOfTests!: number;
    testTime!: number;
    minScore!: number;
    numberOfAttempts!: number;
    taskDeadline!: Date;
    actionStatus!: ActionStatus;

    constructor(data?: ITestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.tastName = _data["tastName"];
            this.description = _data["description"];
            this.spTestTypeId = _data["spTestTypeId"];
            this.showResults = _data["showResults"];
            this.numberOfTests = _data["numberOfTests"];
            this.testTime = _data["testTime"];
            this.minScore = _data["minScore"];
            this.numberOfAttempts = _data["numberOfAttempts"];
            this.taskDeadline = _data["taskDeadline"] ? new Date(_data["taskDeadline"].toString()) : <any>undefined;
            this.actionStatus = _data["actionStatus"];
        }
    }

    static fromJS(data: any): TestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["tastName"] = this.tastName;
        data["description"] = this.description;
        data["spTestTypeId"] = this.spTestTypeId;
        data["showResults"] = this.showResults;
        data["numberOfTests"] = this.numberOfTests;
        data["testTime"] = this.testTime;
        data["minScore"] = this.minScore;
        data["numberOfAttempts"] = this.numberOfAttempts;
        data["taskDeadline"] = this.taskDeadline ? this.taskDeadline.toISOString() : <any>undefined;
        data["actionStatus"] = this.actionStatus;
        return data;
    }
}

export interface ITestDTO {
    id?: number | undefined;
    courseId: number;
    tastName?: string | undefined;
    description?: string | undefined;
    spTestTypeId: number;
    showResults: boolean;
    numberOfTests: number;
    testTime: number;
    minScore: number;
    numberOfAttempts: number;
    taskDeadline: Date;
    actionStatus: ActionStatus;
}

export class TbStaffJoinCourse extends EntityBase implements ITbStaffJoinCourse {
    tbStaffId!: number;
    courseId!: number;

    constructor(data?: ITbStaffJoinCourse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tbStaffId = _data["tbStaffId"];
            this.courseId = _data["courseId"];
        }
    }

    static override fromJS(data: any): TbStaffJoinCourse {
        data = typeof data === 'object' ? data : {};
        let result = new TbStaffJoinCourse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbStaffId"] = this.tbStaffId;
        data["courseId"] = this.courseId;
        super.toJSON(data);
        return data;
    }
}

export interface ITbStaffJoinCourse extends IEntityBase {
    tbStaffId: number;
    courseId: number;
}

export class TreeNodes implements ITreeNodes {
    key?: string | undefined;
    label?: string | undefined;
    data?: string | undefined;
    isCertificate?: boolean | undefined;
    courseProgressLevel!: CourseProgressLevel;
    isPayed!: boolean;
    datatype?: string | undefined;
    initialquiz?: Child | undefined;
    children?: Child[] | undefined;
    finalquiz?: Child | undefined;
    orderId!: number;

    constructor(data?: ITreeNodes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.data = _data["data"];
            this.isCertificate = _data["isCertificate"];
            this.courseProgressLevel = _data["courseProgressLevel"];
            this.isPayed = _data["isPayed"];
            this.datatype = _data["datatype"];
            this.initialquiz = _data["initialquiz"] ? Child.fromJS(_data["initialquiz"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Child.fromJS(item));
            }
            this.finalquiz = _data["finalquiz"] ? Child.fromJS(_data["finalquiz"]) : <any>undefined;
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): TreeNodes {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNodes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["data"] = this.data;
        data["isCertificate"] = this.isCertificate;
        data["courseProgressLevel"] = this.courseProgressLevel;
        data["isPayed"] = this.isPayed;
        data["datatype"] = this.datatype;
        data["initialquiz"] = this.initialquiz ? this.initialquiz.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["finalquiz"] = this.finalquiz ? this.finalquiz.toJSON() : <any>undefined;
        data["orderId"] = this.orderId;
        return data;
    }
}

export interface ITreeNodes {
    key?: string | undefined;
    label?: string | undefined;
    data?: string | undefined;
    isCertificate?: boolean | undefined;
    courseProgressLevel: CourseProgressLevel;
    isPayed: boolean;
    datatype?: string | undefined;
    initialquiz?: Child | undefined;
    children?: Child[] | undefined;
    finalquiz?: Child | undefined;
    orderId: number;
}

export enum CourseProgressLevel {
    Create = 5,
    Start = 10,
    Finish = 20,
    Cancel = 30,
    NotFinished = 40,
    Expired = 50,
}

export class Child implements IChild {
    gpmId?: string | undefined;
    key?: string | undefined;
    label?: string | undefined;
    data?: string | undefined;
    datatype?: string | undefined;
    numberOfQuiz?: number | undefined;
    quizScore?: string | undefined;
    quizType?: string | undefined;
    moduleCredit?: number | undefined;
    isState!: boolean;
    isFinished!: boolean;
    testStatus?: PassTestStatus | undefined;
    children?: Child[] | undefined;

    constructor(data?: IChild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gpmId = _data["gpmId"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.data = _data["data"];
            this.datatype = _data["datatype"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.quizScore = _data["quizScore"];
            this.quizType = _data["quizType"];
            this.moduleCredit = _data["moduleCredit"];
            this.isState = _data["isState"];
            this.isFinished = _data["isFinished"];
            this.testStatus = _data["testStatus"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Child.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Child {
        data = typeof data === 'object' ? data : {};
        let result = new Child();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gpmId"] = this.gpmId;
        data["key"] = this.key;
        data["label"] = this.label;
        data["data"] = this.data;
        data["datatype"] = this.datatype;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["quizScore"] = this.quizScore;
        data["quizType"] = this.quizType;
        data["moduleCredit"] = this.moduleCredit;
        data["isState"] = this.isState;
        data["isFinished"] = this.isFinished;
        data["testStatus"] = this.testStatus;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChild {
    gpmId?: string | undefined;
    key?: string | undefined;
    label?: string | undefined;
    data?: string | undefined;
    datatype?: string | undefined;
    numberOfQuiz?: number | undefined;
    quizScore?: string | undefined;
    quizType?: string | undefined;
    moduleCredit?: number | undefined;
    isState: boolean;
    isFinished: boolean;
    testStatus?: PassTestStatus | undefined;
    children?: Child[] | undefined;
}

export enum PassTestStatus {
    Passed = 0,
    NoPassed = 1,
    NotResolved = 2,
}

export class ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean implements IValueTupleOfNullableIntegerAndNullableIntegerAndBoolean {
    item1?: number | undefined;
    item2?: number | undefined;
    item3!: boolean;

    constructor(data?: IValueTupleOfNullableIntegerAndNullableIntegerAndBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
            this.item3 = _data["item3"];
        }
    }

    static fromJS(data: any): ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfNullableIntegerAndNullableIntegerAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        data["item3"] = this.item3;
        return data;
    }
}

export interface IValueTupleOfNullableIntegerAndNullableIntegerAndBoolean {
    item1?: number | undefined;
    item2?: number | undefined;
    item3: boolean;
}

export class QueryResultOfCourseDTO implements IQueryResultOfCourseDTO {
    totalItems!: number;
    items?: CourseDTO[] | undefined;

    constructor(data?: IQueryResultOfCourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfCourseDTO {
    totalItems: number;
    items?: CourseDTO[] | undefined;
}

export class ValueTupleOfBooleanAndString implements IValueTupleOfBooleanAndString {
    item1!: boolean;
    item2!: string;

    constructor(data?: IValueTupleOfBooleanAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfBooleanAndString {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfBooleanAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfBooleanAndString {
    item1: boolean;
    item2: string;
}

export class OrderUserForCourseDTO implements IOrderUserForCourseDTO {
    id!: number;
    active!: boolean;
    userId!: number;
    courseId!: number;
    try!: number;
    isPayed!: boolean;

    constructor(data?: IOrderUserForCourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.active = _data["active"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.try = _data["try"];
            this.isPayed = _data["isPayed"];
        }
    }

    static fromJS(data: any): OrderUserForCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrderUserForCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["active"] = this.active;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["try"] = this.try;
        data["isPayed"] = this.isPayed;
        return data;
    }
}

export interface IOrderUserForCourseDTO {
    id: number;
    active: boolean;
    userId: number;
    courseId: number;
    try: number;
    isPayed: boolean;
}

export class ResponseDto implements IResponseDto {
    isSuccess!: boolean;
    isExpired!: boolean;
    result?: any | undefined;
    displayMessage?: string | undefined;
    errorMessages?: string[] | undefined;

    constructor(data?: IResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.isExpired = _data["isExpired"];
            this.result = _data["result"];
            this.displayMessage = _data["displayMessage"];
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): ResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["isExpired"] = this.isExpired;
        data["result"] = this.result;
        data["displayMessage"] = this.displayMessage;
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        return data;
    }
}

export interface IResponseDto {
    isSuccess: boolean;
    isExpired: boolean;
    result?: any | undefined;
    displayMessage?: string | undefined;
    errorMessages?: string[] | undefined;
}

export class QueryResultOfStaffCourseStatistics implements IQueryResultOfStaffCourseStatistics {
    totalItems!: number;
    items?: StaffCourseStatistics[] | undefined;

    constructor(data?: IQueryResultOfStaffCourseStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffCourseStatistics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfStaffCourseStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfStaffCourseStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfStaffCourseStatistics {
    totalItems: number;
    items?: StaffCourseStatistics[] | undefined;
}

export class StaffCourseStatistics implements IStaffCourseStatistics {
    courseName?: string | undefined;
    percentProgress!: number;
    staffId!: number;
    userId!: number;
    courseId!: number;
    isGetCertificate!: boolean;
    courseTypeStr?: string | undefined;
    startDate!: Date;
    endDate?: Date | undefined;
    isFinishCourse?: boolean | undefined;
    numberOfAttempts?: string | undefined;
    accumulatedCredits?: string | undefined;

    constructor(data?: IStaffCourseStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseName = _data["courseName"];
            this.percentProgress = _data["percentProgress"];
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.isGetCertificate = _data["isGetCertificate"];
            this.courseTypeStr = _data["courseTypeStr"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isFinishCourse = _data["isFinishCourse"];
            this.numberOfAttempts = _data["numberOfAttempts"];
            this.accumulatedCredits = _data["accumulatedCredits"];
        }
    }

    static fromJS(data: any): StaffCourseStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new StaffCourseStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseName"] = this.courseName;
        data["percentProgress"] = this.percentProgress;
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["isGetCertificate"] = this.isGetCertificate;
        data["courseTypeStr"] = this.courseTypeStr;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isFinishCourse"] = this.isFinishCourse;
        data["numberOfAttempts"] = this.numberOfAttempts;
        data["accumulatedCredits"] = this.accumulatedCredits;
        return data;
    }
}

export interface IStaffCourseStatistics {
    courseName?: string | undefined;
    percentProgress: number;
    staffId: number;
    userId: number;
    courseId: number;
    isGetCertificate: boolean;
    courseTypeStr?: string | undefined;
    startDate: Date;
    endDate?: Date | undefined;
    isFinishCourse?: boolean | undefined;
    numberOfAttempts?: string | undefined;
    accumulatedCredits?: string | undefined;
}

export class QueryResultOfStaffsCourseResults implements IQueryResultOfStaffsCourseResults {
    totalItems!: number;
    items?: StaffsCourseResults[] | undefined;

    constructor(data?: IQueryResultOfStaffsCourseResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffsCourseResults.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfStaffsCourseResults {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfStaffsCourseResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfStaffsCourseResults {
    totalItems: number;
    items?: StaffsCourseResults[] | undefined;
}

export class StaffsCourseResults implements IStaffsCourseResults {
    fullName?: string | undefined;
    accumulatedCredits?: number | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    courseName?: string | undefined;
    percentProgress!: number;
    lastActiveDate?: Date | undefined;
    courseId!: number;
    staffId!: number;
    userId!: number;
    isFinishCourse!: boolean;
    courseCredits?: number | undefined;
    courseProgressId!: number;

    constructor(data?: IStaffsCourseResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.accumulatedCredits = _data["accumulatedCredits"];
            this.workInsitution = _data["workInsitution"];
            this.workPosition = _data["workPosition"];
            this.courseName = _data["courseName"];
            this.percentProgress = _data["percentProgress"];
            this.lastActiveDate = _data["lastActiveDate"] ? new Date(_data["lastActiveDate"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
            this.isFinishCourse = _data["isFinishCourse"];
            this.courseCredits = _data["courseCredits"];
            this.courseProgressId = _data["courseProgressId"];
        }
    }

    static fromJS(data: any): StaffsCourseResults {
        data = typeof data === 'object' ? data : {};
        let result = new StaffsCourseResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["accumulatedCredits"] = this.accumulatedCredits;
        data["workInsitution"] = this.workInsitution;
        data["workPosition"] = this.workPosition;
        data["courseName"] = this.courseName;
        data["percentProgress"] = this.percentProgress;
        data["lastActiveDate"] = this.lastActiveDate ? this.lastActiveDate.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        data["isFinishCourse"] = this.isFinishCourse;
        data["courseCredits"] = this.courseCredits;
        data["courseProgressId"] = this.courseProgressId;
        return data;
    }
}

export interface IStaffsCourseResults {
    fullName?: string | undefined;
    accumulatedCredits?: number | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    courseName?: string | undefined;
    percentProgress: number;
    lastActiveDate?: Date | undefined;
    courseId: number;
    staffId: number;
    userId: number;
    isFinishCourse: boolean;
    courseCredits?: number | undefined;
    courseProgressId: number;
}

export class TaskDiscussionAnswerDTO implements ITaskDiscussionAnswerDTO {
    staffId?: number | undefined;
    taskDiscussionId?: number | undefined;
    textAnswer?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    videoFileId?: string | undefined;
    audioFileId?: string | undefined;

    constructor(data?: ITaskDiscussionAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.taskDiscussionId = _data["taskDiscussionId"];
            this.textAnswer = _data["textAnswer"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.videoFileId = _data["videoFileId"];
            this.audioFileId = _data["audioFileId"];
        }
    }

    static fromJS(data: any): TaskDiscussionAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDiscussionAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["taskDiscussionId"] = this.taskDiscussionId;
        data["textAnswer"] = this.textAnswer;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["videoFileId"] = this.videoFileId;
        data["audioFileId"] = this.audioFileId;
        return data;
    }
}

export interface ITaskDiscussionAnswerDTO {
    staffId?: number | undefined;
    taskDiscussionId?: number | undefined;
    textAnswer?: string | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    videoFileId?: string | undefined;
    audioFileId?: string | undefined;
}

export class DocumentContentDTO implements IDocumentContentDTO {
    id!: number;
    lessonId!: number;
    fileDocumentId!: string;
    title?: string | undefined;
    description?: string | undefined;
    localUrl?: string | undefined;
    fileType?: string | undefined;
    size?: string | undefined;
    uploadDateTime!: Date;

    constructor(data?: IDocumentContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.localUrl = _data["localUrl"];
            this.fileType = _data["fileType"];
            this.size = _data["size"];
            this.uploadDateTime = _data["uploadDateTime"] ? new Date(_data["uploadDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["localUrl"] = this.localUrl;
        data["fileType"] = this.fileType;
        data["size"] = this.size;
        data["uploadDateTime"] = this.uploadDateTime ? this.uploadDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocumentContentDTO {
    id: number;
    lessonId: number;
    fileDocumentId: string;
    title?: string | undefined;
    description?: string | undefined;
    localUrl?: string | undefined;
    fileType?: string | undefined;
    size?: string | undefined;
    uploadDateTime: Date;
}

export class QueryResultOfDocumentContentDTO implements IQueryResultOfDocumentContentDTO {
    totalItems!: number;
    items?: DocumentContentDTO[] | undefined;

    constructor(data?: IQueryResultOfDocumentContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentContentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfDocumentContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfDocumentContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfDocumentContentDTO {
    totalItems: number;
    items?: DocumentContentDTO[] | undefined;
}

export class DocumentDTO implements IDocumentDTO {
    contentType?: string | undefined;
    base64?: string | undefined;

    constructor(data?: IDocumentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
            this.base64 = _data["base64"];
        }
    }

    static fromJS(data: any): DocumentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["base64"] = this.base64;
        return data;
    }
}

export interface IDocumentDTO {
    contentType?: string | undefined;
    base64?: string | undefined;
}

export class FormThemeDTO implements IFormThemeDTO {
    id?: number | undefined;
    themeText?: string | undefined;
    imageFileId?: string | undefined;
    spFormCategoryId!: number;
    createdByName?: string | undefined;
    approvedById?: number | undefined;
    approvedByName?: string | undefined;
    orgId?: number | undefined;
    status?: FormThemeStatus | undefined;
    comentCount?: number | undefined;
    likeCount?: number | undefined;
    disLikeCount?: number | undefined;
    isUserLike?: boolean | undefined;
    comments?: FormCommentDTO[] | undefined;
    formThemeLikes?: FormThemeLike[] | undefined;

    constructor(data?: IFormThemeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.themeText = _data["themeText"];
            this.imageFileId = _data["imageFileId"];
            this.spFormCategoryId = _data["spFormCategoryId"];
            this.createdByName = _data["createdByName"];
            this.approvedById = _data["approvedById"];
            this.approvedByName = _data["approvedByName"];
            this.orgId = _data["orgId"];
            this.status = _data["status"];
            this.comentCount = _data["comentCount"];
            this.likeCount = _data["likeCount"];
            this.disLikeCount = _data["disLikeCount"];
            this.isUserLike = _data["isUserLike"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(FormCommentDTO.fromJS(item));
            }
            if (Array.isArray(_data["formThemeLikes"])) {
                this.formThemeLikes = [] as any;
                for (let item of _data["formThemeLikes"])
                    this.formThemeLikes!.push(FormThemeLike.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormThemeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FormThemeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["themeText"] = this.themeText;
        data["imageFileId"] = this.imageFileId;
        data["spFormCategoryId"] = this.spFormCategoryId;
        data["createdByName"] = this.createdByName;
        data["approvedById"] = this.approvedById;
        data["approvedByName"] = this.approvedByName;
        data["orgId"] = this.orgId;
        data["status"] = this.status;
        data["comentCount"] = this.comentCount;
        data["likeCount"] = this.likeCount;
        data["disLikeCount"] = this.disLikeCount;
        data["isUserLike"] = this.isUserLike;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.formThemeLikes)) {
            data["formThemeLikes"] = [];
            for (let item of this.formThemeLikes)
                data["formThemeLikes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormThemeDTO {
    id?: number | undefined;
    themeText?: string | undefined;
    imageFileId?: string | undefined;
    spFormCategoryId: number;
    createdByName?: string | undefined;
    approvedById?: number | undefined;
    approvedByName?: string | undefined;
    orgId?: number | undefined;
    status?: FormThemeStatus | undefined;
    comentCount?: number | undefined;
    likeCount?: number | undefined;
    disLikeCount?: number | undefined;
    isUserLike?: boolean | undefined;
    comments?: FormCommentDTO[] | undefined;
    formThemeLikes?: FormThemeLike[] | undefined;
}

export enum FormThemeStatus {
    New = 10,
    Edited = 20,
    Confirmed = 30,
    Rejected = 40,
}

export class FormCommentDTO implements IFormCommentDTO {
    id?: number | undefined;
    formThemeId?: number | undefined;
    commentText?: string | undefined;
    createdByName?: string | undefined;
    imageFileId?: string | undefined;
    parentCommentId?: number | undefined;
    orgId?: number | undefined;
    comentCount?: number | undefined;
    likeCount?: number | undefined;
    disLikeCount?: number | undefined;
    isUserLike?: boolean | undefined;
    formCommentLikes?: FormCommentLikeDTO[] | undefined;
    comments?: FormCommentDTO[] | undefined;

    constructor(data?: IFormCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formThemeId = _data["formThemeId"];
            this.commentText = _data["commentText"];
            this.createdByName = _data["createdByName"];
            this.imageFileId = _data["imageFileId"];
            this.parentCommentId = _data["parentCommentId"];
            this.orgId = _data["orgId"];
            this.comentCount = _data["comentCount"];
            this.likeCount = _data["likeCount"];
            this.disLikeCount = _data["disLikeCount"];
            this.isUserLike = _data["isUserLike"];
            if (Array.isArray(_data["formCommentLikes"])) {
                this.formCommentLikes = [] as any;
                for (let item of _data["formCommentLikes"])
                    this.formCommentLikes!.push(FormCommentLikeDTO.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(FormCommentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FormCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formThemeId"] = this.formThemeId;
        data["commentText"] = this.commentText;
        data["createdByName"] = this.createdByName;
        data["imageFileId"] = this.imageFileId;
        data["parentCommentId"] = this.parentCommentId;
        data["orgId"] = this.orgId;
        data["comentCount"] = this.comentCount;
        data["likeCount"] = this.likeCount;
        data["disLikeCount"] = this.disLikeCount;
        data["isUserLike"] = this.isUserLike;
        if (Array.isArray(this.formCommentLikes)) {
            data["formCommentLikes"] = [];
            for (let item of this.formCommentLikes)
                data["formCommentLikes"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormCommentDTO {
    id?: number | undefined;
    formThemeId?: number | undefined;
    commentText?: string | undefined;
    createdByName?: string | undefined;
    imageFileId?: string | undefined;
    parentCommentId?: number | undefined;
    orgId?: number | undefined;
    comentCount?: number | undefined;
    likeCount?: number | undefined;
    disLikeCount?: number | undefined;
    isUserLike?: boolean | undefined;
    formCommentLikes?: FormCommentLikeDTO[] | undefined;
    comments?: FormCommentDTO[] | undefined;
}

export class FormCommentLikeDTO implements IFormCommentLikeDTO {
    id?: number | undefined;
    formCommentId!: number;
    userId!: number;
    createdByName?: string | undefined;
    userStatus!: UserOpinionStatus;

    constructor(data?: IFormCommentLikeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formCommentId = _data["formCommentId"];
            this.userId = _data["userId"];
            this.createdByName = _data["createdByName"];
            this.userStatus = _data["userStatus"];
        }
    }

    static fromJS(data: any): FormCommentLikeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FormCommentLikeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formCommentId"] = this.formCommentId;
        data["userId"] = this.userId;
        data["createdByName"] = this.createdByName;
        data["userStatus"] = this.userStatus;
        return data;
    }
}

export interface IFormCommentLikeDTO {
    id?: number | undefined;
    formCommentId: number;
    userId: number;
    createdByName?: string | undefined;
    userStatus: UserOpinionStatus;
}

export enum UserOpinionStatus {
    NoOpinion = 10,
    Like = 20,
    Dislike = 30,
}

export class FormThemeLike implements IFormThemeLike {
    id!: number;
    formThemeId!: number;
    userId!: number;
    createdByName?: string | undefined;
    userStatus!: UserOpinionStatus;

    constructor(data?: IFormThemeLike) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formThemeId = _data["formThemeId"];
            this.userId = _data["userId"];
            this.createdByName = _data["createdByName"];
            this.userStatus = _data["userStatus"];
        }
    }

    static fromJS(data: any): FormThemeLike {
        data = typeof data === 'object' ? data : {};
        let result = new FormThemeLike();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formThemeId"] = this.formThemeId;
        data["userId"] = this.userId;
        data["createdByName"] = this.createdByName;
        data["userStatus"] = this.userStatus;
        return data;
    }
}

export interface IFormThemeLike {
    id: number;
    formThemeId: number;
    userId: number;
    createdByName?: string | undefined;
    userStatus: UserOpinionStatus;
}

export class ValueTupleOfFormThemeDTOAndBoolean implements IValueTupleOfFormThemeDTOAndBoolean {
    item1!: FormThemeDTO;
    item2!: boolean;

    constructor(data?: IValueTupleOfFormThemeDTOAndBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item1 = new FormThemeDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"] ? FormThemeDTO.fromJS(_data["item1"]) : new FormThemeDTO();
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfFormThemeDTOAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfFormThemeDTOAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1 ? this.item1.toJSON() : <any>undefined;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfFormThemeDTOAndBoolean {
    item1: FormThemeDTO;
    item2: boolean;
}

export class QueryResultOfFormThemeDTO implements IQueryResultOfFormThemeDTO {
    totalItems!: number;
    items?: FormThemeDTO[] | undefined;

    constructor(data?: IQueryResultOfFormThemeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormThemeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfFormThemeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfFormThemeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfFormThemeDTO {
    totalItems: number;
    items?: FormThemeDTO[] | undefined;
}

export class FormThemeLikeDTO implements IFormThemeLikeDTO {
    id?: number | undefined;
    formThemeId!: number;
    userId?: number | undefined;
    createdByName?: string | undefined;
    userStatus!: UserOpinionStatus;

    constructor(data?: IFormThemeLikeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formThemeId = _data["formThemeId"];
            this.userId = _data["userId"];
            this.createdByName = _data["createdByName"];
            this.userStatus = _data["userStatus"];
        }
    }

    static fromJS(data: any): FormThemeLikeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FormThemeLikeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formThemeId"] = this.formThemeId;
        data["userId"] = this.userId;
        data["createdByName"] = this.createdByName;
        data["userStatus"] = this.userStatus;
        return data;
    }
}

export interface IFormThemeLikeDTO {
    id?: number | undefined;
    formThemeId: number;
    userId?: number | undefined;
    createdByName?: string | undefined;
    userStatus: UserOpinionStatus;
}

export class GeneralContentDTO implements IGeneralContentDTO {
    id?: number | undefined;
    lessonId!: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId?: string | undefined;
    audioUploadType?: AudioUploadType | undefined;
    fileDocumentId?: string | undefined;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId?: string | undefined;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId?: string | undefined;
    videoUploadType?: VideoUploadType | undefined;
    typeGeneralContent?: TypeGeneralContent | undefined;
    codeForOrder?: number | undefined;
    fileNameStr?: string | undefined;

    constructor(data?: IGeneralContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.sectionNumber = _data["sectionNumber"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.fileAudioId = _data["fileAudioId"];
            this.audioUploadType = _data["audioUploadType"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.fileType = _data["fileType"];
            this.fileSize = _data["fileSize"];
            this.fileImageId = _data["fileImageId"];
            this.youTubeUrl = _data["youTubeUrl"];
            this.webUrl = _data["webUrl"];
            this.localUrl = _data["localUrl"];
            this.fileVideoId = _data["fileVideoId"];
            this.videoUploadType = _data["videoUploadType"];
            this.typeGeneralContent = _data["typeGeneralContent"];
            this.codeForOrder = _data["codeForOrder"];
            this.fileNameStr = _data["fileNameStr"];
        }
    }

    static fromJS(data: any): GeneralContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["sectionNumber"] = this.sectionNumber;
        data["title"] = this.title;
        data["description"] = this.description;
        data["fileAudioId"] = this.fileAudioId;
        data["audioUploadType"] = this.audioUploadType;
        data["fileDocumentId"] = this.fileDocumentId;
        data["fileType"] = this.fileType;
        data["fileSize"] = this.fileSize;
        data["fileImageId"] = this.fileImageId;
        data["youTubeUrl"] = this.youTubeUrl;
        data["webUrl"] = this.webUrl;
        data["localUrl"] = this.localUrl;
        data["fileVideoId"] = this.fileVideoId;
        data["videoUploadType"] = this.videoUploadType;
        data["typeGeneralContent"] = this.typeGeneralContent;
        data["codeForOrder"] = this.codeForOrder;
        data["fileNameStr"] = this.fileNameStr;
        return data;
    }
}

export interface IGeneralContentDTO {
    id?: number | undefined;
    lessonId: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId?: string | undefined;
    audioUploadType?: AudioUploadType | undefined;
    fileDocumentId?: string | undefined;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId?: string | undefined;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId?: string | undefined;
    videoUploadType?: VideoUploadType | undefined;
    typeGeneralContent?: TypeGeneralContent | undefined;
    codeForOrder?: number | undefined;
    fileNameStr?: string | undefined;
}

export class QueryResultOfGeneralContentDTO implements IQueryResultOfGeneralContentDTO {
    totalItems!: number;
    items?: GeneralContentDTO[] | undefined;

    constructor(data?: IQueryResultOfGeneralContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GeneralContentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfGeneralContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfGeneralContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfGeneralContentDTO {
    totalItems: number;
    items?: GeneralContentDTO[] | undefined;
}

export class UserLastStepContentDTO implements IUserLastStepContentDTO {
    id!: number;
    lessonId!: number;
    moduleId!: number;
    courseId!: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId!: string;
    audioUploadType!: AudioUploadType;
    fileDocumentId!: string;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId!: string;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId!: string;
    videoUploadType!: VideoUploadType;
    typeGeneralContent!: TypeGeneralContent;
    codeForOrder!: number;

    constructor(data?: IUserLastStepContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.moduleId = _data["moduleId"];
            this.courseId = _data["courseId"];
            this.sectionNumber = _data["sectionNumber"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.fileAudioId = _data["fileAudioId"];
            this.audioUploadType = _data["audioUploadType"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.fileType = _data["fileType"];
            this.fileSize = _data["fileSize"];
            this.fileImageId = _data["fileImageId"];
            this.youTubeUrl = _data["youTubeUrl"];
            this.webUrl = _data["webUrl"];
            this.localUrl = _data["localUrl"];
            this.fileVideoId = _data["fileVideoId"];
            this.videoUploadType = _data["videoUploadType"];
            this.typeGeneralContent = _data["typeGeneralContent"];
            this.codeForOrder = _data["codeForOrder"];
        }
    }

    static fromJS(data: any): UserLastStepContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLastStepContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["moduleId"] = this.moduleId;
        data["courseId"] = this.courseId;
        data["sectionNumber"] = this.sectionNumber;
        data["title"] = this.title;
        data["description"] = this.description;
        data["fileAudioId"] = this.fileAudioId;
        data["audioUploadType"] = this.audioUploadType;
        data["fileDocumentId"] = this.fileDocumentId;
        data["fileType"] = this.fileType;
        data["fileSize"] = this.fileSize;
        data["fileImageId"] = this.fileImageId;
        data["youTubeUrl"] = this.youTubeUrl;
        data["webUrl"] = this.webUrl;
        data["localUrl"] = this.localUrl;
        data["fileVideoId"] = this.fileVideoId;
        data["videoUploadType"] = this.videoUploadType;
        data["typeGeneralContent"] = this.typeGeneralContent;
        data["codeForOrder"] = this.codeForOrder;
        return data;
    }
}

export interface IUserLastStepContentDTO {
    id: number;
    lessonId: number;
    moduleId: number;
    courseId: number;
    sectionNumber?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fileAudioId: string;
    audioUploadType: AudioUploadType;
    fileDocumentId: string;
    fileType?: string | undefined;
    fileSize?: string | undefined;
    fileImageId: string;
    youTubeUrl?: string | undefined;
    webUrl?: string | undefined;
    localUrl?: string | undefined;
    fileVideoId: string;
    videoUploadType: VideoUploadType;
    typeGeneralContent: TypeGeneralContent;
    codeForOrder: number;
}

export class GiveFeedbackDTO implements IGiveFeedbackDTO {
    peerReviewAnswerId!: number;
    staffId!: number;
    textFeedback?: string | undefined;
    score!: number;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;

    constructor(data?: IGiveFeedbackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.peerReviewAnswerId = _data["peerReviewAnswerId"];
            this.staffId = _data["staffId"];
            this.textFeedback = _data["textFeedback"];
            this.score = _data["score"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
        }
    }

    static fromJS(data: any): GiveFeedbackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GiveFeedbackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["peerReviewAnswerId"] = this.peerReviewAnswerId;
        data["staffId"] = this.staffId;
        data["textFeedback"] = this.textFeedback;
        data["score"] = this.score;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        return data;
    }
}

export interface IGiveFeedbackDTO {
    peerReviewAnswerId: number;
    staffId: number;
    textFeedback?: string | undefined;
    score: number;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
}

export class LessonDTO implements ILessonDTO {
    id?: number | undefined;
    generalPartModuleId?: number | undefined;
    imageFileId?: string | undefined;
    lessonName?: string | undefined;
    description?: string | undefined;
    codeForOrder?: number | undefined;
    generalContents?: GeneralContentDTO[] | undefined;

    constructor(data?: ILessonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.imageFileId = _data["imageFileId"];
            this.lessonName = _data["lessonName"];
            this.description = _data["description"];
            this.codeForOrder = _data["codeForOrder"];
            if (Array.isArray(_data["generalContents"])) {
                this.generalContents = [] as any;
                for (let item of _data["generalContents"])
                    this.generalContents!.push(GeneralContentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LessonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["imageFileId"] = this.imageFileId;
        data["lessonName"] = this.lessonName;
        data["description"] = this.description;
        data["codeForOrder"] = this.codeForOrder;
        if (Array.isArray(this.generalContents)) {
            data["generalContents"] = [];
            for (let item of this.generalContents)
                data["generalContents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILessonDTO {
    id?: number | undefined;
    generalPartModuleId?: number | undefined;
    imageFileId?: string | undefined;
    lessonName?: string | undefined;
    description?: string | undefined;
    codeForOrder?: number | undefined;
    generalContents?: GeneralContentDTO[] | undefined;
}

export class QueryResultOfLessonDTO implements IQueryResultOfLessonDTO {
    totalItems!: number;
    items?: LessonDTO[] | undefined;

    constructor(data?: IQueryResultOfLessonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LessonDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfLessonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfLessonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfLessonDTO {
    totalItems: number;
    items?: LessonDTO[] | undefined;
}

export class QueryResultOfModuleDTO implements IQueryResultOfModuleDTO {
    totalItems!: number;
    items?: ModuleDTO[] | undefined;

    constructor(data?: IQueryResultOfModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfModuleDTO {
    totalItems: number;
    items?: ModuleDTO[] | undefined;
}

export class ValueTupleOfListOfNotificationDTOAndInteger implements IValueTupleOfListOfNotificationDTOAndInteger {
    item1!: NotificationDTO[];
    item2!: number;

    constructor(data?: IValueTupleOfListOfNotificationDTOAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item1 = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["item1"])) {
                this.item1 = [] as any;
                for (let item of _data["item1"])
                    this.item1!.push(NotificationDTO.fromJS(item));
            }
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfListOfNotificationDTOAndInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfListOfNotificationDTOAndInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item1)) {
            data["item1"] = [];
            for (let item of this.item1)
                data["item1"].push(item.toJSON());
        }
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfListOfNotificationDTOAndInteger {
    item1: NotificationDTO[];
    item2: number;
}

export class NotificationDTO implements INotificationDTO {
    id?: number | undefined;
    orgId?: number | undefined;
    text?: string | undefined;
    createdDate!: Date;
    active?: boolean | undefined;
    userId?: number | undefined;
    isView!: boolean;
    viewDate?: Date | undefined;
    status!: NotificationStatus;

    constructor(data?: INotificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orgId = _data["orgId"];
            this.text = _data["text"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            this.userId = _data["userId"];
            this.isView = _data["isView"];
            this.viewDate = _data["viewDate"] ? new Date(_data["viewDate"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): NotificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        data["text"] = this.text;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        data["userId"] = this.userId;
        data["isView"] = this.isView;
        data["viewDate"] = this.viewDate ? this.viewDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface INotificationDTO {
    id?: number | undefined;
    orgId?: number | undefined;
    text?: string | undefined;
    createdDate: Date;
    active?: boolean | undefined;
    userId?: number | undefined;
    isView: boolean;
    viewDate?: Date | undefined;
    status: NotificationStatus;
}

export enum NotificationStatus {
    ForAllUsers = 10,
    ForOneUser = 20,
}

export class OrganizationDTO implements IOrganizationDTO {
    id!: number;
    orgName?: string | undefined;
    orgINN?: string | undefined;
    orgLeader?: string | undefined;
    orgLeaderWorkPosition?: string | undefined;
    orgPhoneNumber?: string | undefined;
    orgEmailAddress?: string | undefined;
    orgAddress?: string | undefined;
    orgAccountNumber?: string | undefined;
    orgMFO?: string | undefined;
    domainName?: string | undefined;

    constructor(data?: IOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orgName = _data["orgName"];
            this.orgINN = _data["orgINN"];
            this.orgLeader = _data["orgLeader"];
            this.orgLeaderWorkPosition = _data["orgLeaderWorkPosition"];
            this.orgPhoneNumber = _data["orgPhoneNumber"];
            this.orgEmailAddress = _data["orgEmailAddress"];
            this.orgAddress = _data["orgAddress"];
            this.orgAccountNumber = _data["orgAccountNumber"];
            this.orgMFO = _data["orgMFO"];
            this.domainName = _data["domainName"];
        }
    }

    static fromJS(data: any): OrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orgName"] = this.orgName;
        data["orgINN"] = this.orgINN;
        data["orgLeader"] = this.orgLeader;
        data["orgLeaderWorkPosition"] = this.orgLeaderWorkPosition;
        data["orgPhoneNumber"] = this.orgPhoneNumber;
        data["orgEmailAddress"] = this.orgEmailAddress;
        data["orgAddress"] = this.orgAddress;
        data["orgAccountNumber"] = this.orgAccountNumber;
        data["orgMFO"] = this.orgMFO;
        data["domainName"] = this.domainName;
        return data;
    }
}

export interface IOrganizationDTO {
    id: number;
    orgName?: string | undefined;
    orgINN?: string | undefined;
    orgLeader?: string | undefined;
    orgLeaderWorkPosition?: string | undefined;
    orgPhoneNumber?: string | undefined;
    orgEmailAddress?: string | undefined;
    orgAddress?: string | undefined;
    orgAccountNumber?: string | undefined;
    orgMFO?: string | undefined;
    domainName?: string | undefined;
}

export class QueryResultOfOrganizationDTO implements IQueryResultOfOrganizationDTO {
    totalItems!: number;
    items?: OrganizationDTO[] | undefined;

    constructor(data?: IQueryResultOfOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfOrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfOrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfOrganizationDTO {
    totalItems: number;
    items?: OrganizationDTO[] | undefined;
}

export class SelectItem implements ISelectItem {
    label?: string | undefined;
    value?: string | undefined;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;
    comment?: string | undefined;
    booleanProperty?: boolean | undefined;
    orgId?: number | undefined;

    constructor(data?: ISelectItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
            this.dataInt = _data["dataInt"];
            this.code = _data["code"];
            this.rootCode = _data["rootCode"];
            this.dataStr = _data["dataStr"];
            this.dataStr2 = _data["dataStr2"];
            this.dateTime = _data["dateTime"];
            this.comment = _data["comment"];
            this.booleanProperty = _data["booleanProperty"];
            this.orgId = _data["orgId"];
        }
    }

    static fromJS(data: any): SelectItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        data["dataInt"] = this.dataInt;
        data["code"] = this.code;
        data["rootCode"] = this.rootCode;
        data["dataStr"] = this.dataStr;
        data["dataStr2"] = this.dataStr2;
        data["dateTime"] = this.dateTime;
        data["comment"] = this.comment;
        data["booleanProperty"] = this.booleanProperty;
        data["orgId"] = this.orgId;
        return data;
    }
}

export interface ISelectItem {
    label?: string | undefined;
    value?: string | undefined;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;
    comment?: string | undefined;
    booleanProperty?: boolean | undefined;
    orgId?: number | undefined;
}

export class PaymeResponse implements IPaymeResponse {
    id!: number;
    result?: any | undefined;
    error?: any | undefined;

    constructor(data?: IPaymeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.result = _data["result"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): PaymeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["result"] = this.result;
        data["error"] = this.error;
        return data;
    }
}

export interface IPaymeResponse {
    id: number;
    result?: any | undefined;
    error?: any | undefined;
}

export class PaymeViewModel implements IPaymeViewModel {
    id!: number;
    jsonrpc?: string | undefined;
    method?: string | undefined;
    params?: Params | undefined;

    constructor(data?: IPaymeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jsonrpc = _data["jsonrpc"];
            this.method = _data["method"];
            this.params = _data["params"] ? Params.fromJS(_data["params"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jsonrpc"] = this.jsonrpc;
        data["method"] = this.method;
        data["params"] = this.params ? this.params.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymeViewModel {
    id: number;
    jsonrpc?: string | undefined;
    method?: string | undefined;
    params?: Params | undefined;
}

export class Params implements IParams {
    id?: string | undefined;
    time!: number;
    from!: number;
    to!: number;
    reason!: number;
    amount!: number;
    account?: Account | undefined;

    constructor(data?: IParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.time = _data["time"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.reason = _data["reason"];
            this.amount = _data["amount"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Params {
        data = typeof data === 'object' ? data : {};
        let result = new Params();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["time"] = this.time;
        data["from"] = this.from;
        data["to"] = this.to;
        data["reason"] = this.reason;
        data["amount"] = this.amount;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParams {
    id?: string | undefined;
    time: number;
    from: number;
    to: number;
    reason: number;
    amount: number;
    account?: Account | undefined;
}

export class Account implements IAccount {
    order_id?: string | undefined;
    user_id?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order_id = _data["order_id"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order_id"] = this.order_id;
        data["user_id"] = this.user_id;
        return data;
    }
}

export interface IAccount {
    order_id?: string | undefined;
    user_id?: string | undefined;
}

export class PeerReviewAnswerDTO implements IPeerReviewAnswerDTO {
    id?: number | undefined;
    peerReviewId!: number;
    staffId!: number;
    textAnswer?: string | undefined;
    giveFeedbacks?: GiveFeedback[] | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;

    constructor(data?: IPeerReviewAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.peerReviewId = _data["peerReviewId"];
            this.staffId = _data["staffId"];
            this.textAnswer = _data["textAnswer"];
            if (Array.isArray(_data["giveFeedbacks"])) {
                this.giveFeedbacks = [] as any;
                for (let item of _data["giveFeedbacks"])
                    this.giveFeedbacks!.push(GiveFeedback.fromJS(item));
            }
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
        }
    }

    static fromJS(data: any): PeerReviewAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PeerReviewAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["peerReviewId"] = this.peerReviewId;
        data["staffId"] = this.staffId;
        data["textAnswer"] = this.textAnswer;
        if (Array.isArray(this.giveFeedbacks)) {
            data["giveFeedbacks"] = [];
            for (let item of this.giveFeedbacks)
                data["giveFeedbacks"].push(item.toJSON());
        }
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        return data;
    }
}

export interface IPeerReviewAnswerDTO {
    id?: number | undefined;
    peerReviewId: number;
    staffId: number;
    textAnswer?: string | undefined;
    giveFeedbacks?: GiveFeedback[] | undefined;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
}

export class GiveFeedback extends EntityBase implements IGiveFeedback {
    peerReviewAnswerId!: number;
    staffId!: number;
    textFeedback?: string | undefined;
    score!: number;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;

    constructor(data?: IGiveFeedback) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.peerReviewAnswerId = _data["peerReviewAnswerId"];
            this.staffId = _data["staffId"];
            this.textFeedback = _data["textFeedback"];
            this.score = _data["score"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
        }
    }

    static override fromJS(data: any): GiveFeedback {
        data = typeof data === 'object' ? data : {};
        let result = new GiveFeedback();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["peerReviewAnswerId"] = this.peerReviewAnswerId;
        data["staffId"] = this.staffId;
        data["textFeedback"] = this.textFeedback;
        data["score"] = this.score;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        super.toJSON(data);
        return data;
    }
}

export interface IGiveFeedback extends IEntityBase {
    peerReviewAnswerId: number;
    staffId: number;
    textFeedback?: string | undefined;
    score: number;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
}

export class PhotoContentDTO implements IPhotoContentDTO {
    id!: number;
    lessonId!: number;
    fileImageId!: string;
    title?: string | undefined;
    description?: string | undefined;
    youTubeUrl?: string | undefined;
    localUrl?: string | undefined;

    constructor(data?: IPhotoContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.fileImageId = _data["fileImageId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.youTubeUrl = _data["youTubeUrl"];
            this.localUrl = _data["localUrl"];
        }
    }

    static fromJS(data: any): PhotoContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["fileImageId"] = this.fileImageId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["youTubeUrl"] = this.youTubeUrl;
        data["localUrl"] = this.localUrl;
        return data;
    }
}

export interface IPhotoContentDTO {
    id: number;
    lessonId: number;
    fileImageId: string;
    title?: string | undefined;
    description?: string | undefined;
    youTubeUrl?: string | undefined;
    localUrl?: string | undefined;
}

export class TQuestionDTO implements ITQuestionDTO {
    id?: number | undefined;
    testId!: number;
    question?: string | undefined;
    questionAnswers?: TQuestionAnswerDTO[] | undefined;

    constructor(data?: ITQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.testId = _data["testId"];
            this.question = _data["question"];
            if (Array.isArray(_data["questionAnswers"])) {
                this.questionAnswers = [] as any;
                for (let item of _data["questionAnswers"])
                    this.questionAnswers!.push(TQuestionAnswerDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TQuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TQuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["testId"] = this.testId;
        data["question"] = this.question;
        if (Array.isArray(this.questionAnswers)) {
            data["questionAnswers"] = [];
            for (let item of this.questionAnswers)
                data["questionAnswers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITQuestionDTO {
    id?: number | undefined;
    testId: number;
    question?: string | undefined;
    questionAnswers?: TQuestionAnswerDTO[] | undefined;
}

export class TQuestionAnswerDTO implements ITQuestionAnswerDTO {
    tQuestionId!: number;
    answer?: string | undefined;
    trueAnswer!: boolean;

    constructor(data?: ITQuestionAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tQuestionId = _data["tQuestionId"];
            this.answer = _data["answer"];
            this.trueAnswer = _data["trueAnswer"];
        }
    }

    static fromJS(data: any): TQuestionAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TQuestionAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tQuestionId"] = this.tQuestionId;
        data["answer"] = this.answer;
        data["trueAnswer"] = this.trueAnswer;
        return data;
    }
}

export interface ITQuestionAnswerDTO {
    tQuestionId: number;
    answer?: string | undefined;
    trueAnswer: boolean;
}

export class QuizDTO implements IQuizDTO {
    id?: number | undefined;
    courseId?: number | undefined;
    generalPartModuleId?: number | undefined;
    quizName?: string | undefined;
    spQuizTimeId!: number;
    quizTime!: number;
    maxScore!: number;
    numberOfQuiz!: number;
    passingScore!: number;
    numberAttempts!: number;
    isShowRihgtAnswer!: boolean;
    isBackQuestion!: boolean;
    deadline?: Date | undefined;
    quizType!: QuizType;
    quizLevelQuestions?: QuizLevelQuestionDTO[] | undefined;

    constructor(data?: IQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.quizName = _data["quizName"];
            this.spQuizTimeId = _data["spQuizTimeId"];
            this.quizTime = _data["quizTime"];
            this.maxScore = _data["maxScore"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.passingScore = _data["passingScore"];
            this.numberAttempts = _data["numberAttempts"];
            this.isShowRihgtAnswer = _data["isShowRihgtAnswer"];
            this.isBackQuestion = _data["isBackQuestion"];
            this.deadline = _data["deadline"] ? new Date(_data["deadline"].toString()) : <any>undefined;
            this.quizType = _data["quizType"];
            if (Array.isArray(_data["quizLevelQuestions"])) {
                this.quizLevelQuestions = [] as any;
                for (let item of _data["quizLevelQuestions"])
                    this.quizLevelQuestions!.push(QuizLevelQuestionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["quizName"] = this.quizName;
        data["spQuizTimeId"] = this.spQuizTimeId;
        data["quizTime"] = this.quizTime;
        data["maxScore"] = this.maxScore;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["passingScore"] = this.passingScore;
        data["numberAttempts"] = this.numberAttempts;
        data["isShowRihgtAnswer"] = this.isShowRihgtAnswer;
        data["isBackQuestion"] = this.isBackQuestion;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["quizType"] = this.quizType;
        if (Array.isArray(this.quizLevelQuestions)) {
            data["quizLevelQuestions"] = [];
            for (let item of this.quizLevelQuestions)
                data["quizLevelQuestions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizDTO {
    id?: number | undefined;
    courseId?: number | undefined;
    generalPartModuleId?: number | undefined;
    quizName?: string | undefined;
    spQuizTimeId: number;
    quizTime: number;
    maxScore: number;
    numberOfQuiz: number;
    passingScore: number;
    numberAttempts: number;
    isShowRihgtAnswer: boolean;
    isBackQuestion: boolean;
    deadline?: Date | undefined;
    quizType: QuizType;
    quizLevelQuestions?: QuizLevelQuestionDTO[] | undefined;
}

export class QuizLevelQuestionDTO implements IQuizLevelQuestionDTO {
    id?: number | undefined;
    quizId?: number | undefined;
    levelQuestionName?: string | undefined;
    numberOfQuizLevel!: number;
    quizQuestionCategories?: QuizQuestionCategoryDTO[] | undefined;

    constructor(data?: IQuizLevelQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quizId = _data["quizId"];
            this.levelQuestionName = _data["levelQuestionName"];
            this.numberOfQuizLevel = _data["numberOfQuizLevel"];
            if (Array.isArray(_data["quizQuestionCategories"])) {
                this.quizQuestionCategories = [] as any;
                for (let item of _data["quizQuestionCategories"])
                    this.quizQuestionCategories!.push(QuizQuestionCategoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizLevelQuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizLevelQuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quizId"] = this.quizId;
        data["levelQuestionName"] = this.levelQuestionName;
        data["numberOfQuizLevel"] = this.numberOfQuizLevel;
        if (Array.isArray(this.quizQuestionCategories)) {
            data["quizQuestionCategories"] = [];
            for (let item of this.quizQuestionCategories)
                data["quizQuestionCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizLevelQuestionDTO {
    id?: number | undefined;
    quizId?: number | undefined;
    levelQuestionName?: string | undefined;
    numberOfQuizLevel: number;
    quizQuestionCategories?: QuizQuestionCategoryDTO[] | undefined;
}

export class QuizQuestionCategoryDTO implements IQuizQuestionCategoryDTO {
    id?: number | undefined;
    quizLevelQuestionId?: number | undefined;
    spQuizQuestionCategoryId!: number;
    numberOfQuizQuestion!: number;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestions?: QuizQuestionDTO[] | undefined;

    constructor(data?: IQuizQuestionCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quizLevelQuestionId = _data["quizLevelQuestionId"];
            this.spQuizQuestionCategoryId = _data["spQuizQuestionCategoryId"];
            this.numberOfQuizQuestion = _data["numberOfQuizQuestion"];
            this.quizQuestionType = _data["quizQuestionType"];
            if (Array.isArray(_data["quizQuestions"])) {
                this.quizQuestions = [] as any;
                for (let item of _data["quizQuestions"])
                    this.quizQuestions!.push(QuizQuestionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestionCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quizLevelQuestionId"] = this.quizLevelQuestionId;
        data["spQuizQuestionCategoryId"] = this.spQuizQuestionCategoryId;
        data["numberOfQuizQuestion"] = this.numberOfQuizQuestion;
        data["quizQuestionType"] = this.quizQuestionType;
        if (Array.isArray(this.quizQuestions)) {
            data["quizQuestions"] = [];
            for (let item of this.quizQuestions)
                data["quizQuestions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizQuestionCategoryDTO {
    id?: number | undefined;
    quizLevelQuestionId?: number | undefined;
    spQuizQuestionCategoryId: number;
    numberOfQuizQuestion: number;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestions?: QuizQuestionDTO[] | undefined;
}

export class QuizQuestionDTO implements IQuizQuestionDTO {
    id?: number | undefined;
    quizQuestionCategoryId!: number;
    quizQuestionText?: string | undefined;
    imageFileId?: string | undefined;
    isMultiple?: boolean | undefined;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestionAnswers?: QuizQuestionAnswerDTO[] | undefined;
    matchingQuestionAnswers?: MatchingQuestionAnswerDTO[] | undefined;

    constructor(data?: IQuizQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quizQuestionCategoryId = _data["quizQuestionCategoryId"];
            this.quizQuestionText = _data["quizQuestionText"];
            this.imageFileId = _data["imageFileId"];
            this.isMultiple = _data["isMultiple"];
            this.quizQuestionType = _data["quizQuestionType"];
            if (Array.isArray(_data["quizQuestionAnswers"])) {
                this.quizQuestionAnswers = [] as any;
                for (let item of _data["quizQuestionAnswers"])
                    this.quizQuestionAnswers!.push(QuizQuestionAnswerDTO.fromJS(item));
            }
            if (Array.isArray(_data["matchingQuestionAnswers"])) {
                this.matchingQuestionAnswers = [] as any;
                for (let item of _data["matchingQuestionAnswers"])
                    this.matchingQuestionAnswers!.push(MatchingQuestionAnswerDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quizQuestionCategoryId"] = this.quizQuestionCategoryId;
        data["quizQuestionText"] = this.quizQuestionText;
        data["imageFileId"] = this.imageFileId;
        data["isMultiple"] = this.isMultiple;
        data["quizQuestionType"] = this.quizQuestionType;
        if (Array.isArray(this.quizQuestionAnswers)) {
            data["quizQuestionAnswers"] = [];
            for (let item of this.quizQuestionAnswers)
                data["quizQuestionAnswers"].push(item.toJSON());
        }
        if (Array.isArray(this.matchingQuestionAnswers)) {
            data["matchingQuestionAnswers"] = [];
            for (let item of this.matchingQuestionAnswers)
                data["matchingQuestionAnswers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizQuestionDTO {
    id?: number | undefined;
    quizQuestionCategoryId: number;
    quizQuestionText?: string | undefined;
    imageFileId?: string | undefined;
    isMultiple?: boolean | undefined;
    quizQuestionType?: QuizQuestionType | undefined;
    quizQuestionAnswers?: QuizQuestionAnswerDTO[] | undefined;
    matchingQuestionAnswers?: MatchingQuestionAnswerDTO[] | undefined;
}

export class QuizQuestionAnswerDTO implements IQuizQuestionAnswerDTO {
    id?: number | undefined;
    quizQuestionId!: number;
    answerText?: string | undefined;
    answerTextMatch?: string | undefined;
    isRight?: boolean | undefined;
    imageFileId?: string | undefined;

    constructor(data?: IQuizQuestionAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quizQuestionId = _data["quizQuestionId"];
            this.answerText = _data["answerText"];
            this.answerTextMatch = _data["answerTextMatch"];
            this.isRight = _data["isRight"];
            this.imageFileId = _data["imageFileId"];
        }
    }

    static fromJS(data: any): QuizQuestionAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quizQuestionId"] = this.quizQuestionId;
        data["answerText"] = this.answerText;
        data["answerTextMatch"] = this.answerTextMatch;
        data["isRight"] = this.isRight;
        data["imageFileId"] = this.imageFileId;
        return data;
    }
}

export interface IQuizQuestionAnswerDTO {
    id?: number | undefined;
    quizQuestionId: number;
    answerText?: string | undefined;
    answerTextMatch?: string | undefined;
    isRight?: boolean | undefined;
    imageFileId?: string | undefined;
}

export class MatchingQuestionAnswerDTO implements IMatchingQuestionAnswerDTO {
    id?: number | undefined;
    answerTextMatch?: string | undefined;

    constructor(data?: IMatchingQuestionAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerTextMatch = _data["answerTextMatch"];
        }
    }

    static fromJS(data: any): MatchingQuestionAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchingQuestionAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerTextMatch"] = this.answerTextMatch;
        return data;
    }
}

export interface IMatchingQuestionAnswerDTO {
    id?: number | undefined;
    answerTextMatch?: string | undefined;
}

export class ValueTupleOfIntegerAndBoolean implements IValueTupleOfIntegerAndBoolean {
    item1!: number;
    item2!: boolean;

    constructor(data?: IValueTupleOfIntegerAndBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfIntegerAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfIntegerAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfIntegerAndBoolean {
    item1: number;
    item2: boolean;
}

export class QuizResultDTO implements IQuizResultDTO {
    quizId!: number;
    staffId!: number;
    userId!: number;
    correctAnswerResult!: number;
    wrongAnswerResult?: number | undefined;
    attempt!: number;
    percentOfQuizCorrectAnswer?: number | undefined;
    finishedDate!: Date;
    passTestStatus!: PassTestStatus;

    constructor(data?: IQuizResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
            this.correctAnswerResult = _data["correctAnswerResult"];
            this.wrongAnswerResult = _data["wrongAnswerResult"];
            this.attempt = _data["attempt"];
            this.percentOfQuizCorrectAnswer = _data["percentOfQuizCorrectAnswer"];
            this.finishedDate = _data["finishedDate"] ? new Date(_data["finishedDate"].toString()) : <any>undefined;
            this.passTestStatus = _data["passTestStatus"];
        }
    }

    static fromJS(data: any): QuizResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        data["correctAnswerResult"] = this.correctAnswerResult;
        data["wrongAnswerResult"] = this.wrongAnswerResult;
        data["attempt"] = this.attempt;
        data["percentOfQuizCorrectAnswer"] = this.percentOfQuizCorrectAnswer;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toISOString() : <any>undefined;
        data["passTestStatus"] = this.passTestStatus;
        return data;
    }
}

export interface IQuizResultDTO {
    quizId: number;
    staffId: number;
    userId: number;
    correctAnswerResult: number;
    wrongAnswerResult?: number | undefined;
    attempt: number;
    percentOfQuizCorrectAnswer?: number | undefined;
    finishedDate: Date;
    passTestStatus: PassTestStatus;
}

export class QuizCheckModel implements IQuizCheckModel {
    quizId!: number;
    quizName?: string | undefined;
    staffId?: number | undefined;
    quizQuestions?: QuizQuestionCheck[] | undefined;

    constructor(data?: IQuizCheckModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            this.quizName = _data["quizName"];
            this.staffId = _data["staffId"];
            if (Array.isArray(_data["quizQuestions"])) {
                this.quizQuestions = [] as any;
                for (let item of _data["quizQuestions"])
                    this.quizQuestions!.push(QuizQuestionCheck.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizCheckModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuizCheckModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["quizName"] = this.quizName;
        data["staffId"] = this.staffId;
        if (Array.isArray(this.quizQuestions)) {
            data["quizQuestions"] = [];
            for (let item of this.quizQuestions)
                data["quizQuestions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizCheckModel {
    quizId: number;
    quizName?: string | undefined;
    staffId?: number | undefined;
    quizQuestions?: QuizQuestionCheck[] | undefined;
}

export class QuizQuestionCheck implements IQuizQuestionCheck {
    quizQuestionId!: number;
    quizQuestionCategoryId?: number | undefined;
    answers?: QuizQuestionAnswerCheck[] | undefined;

    constructor(data?: IQuizQuestionCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizQuestionId = _data["quizQuestionId"];
            this.quizQuestionCategoryId = _data["quizQuestionCategoryId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(QuizQuestionAnswerCheck.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestionCheck {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizQuestionId"] = this.quizQuestionId;
        data["quizQuestionCategoryId"] = this.quizQuestionCategoryId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizQuestionCheck {
    quizQuestionId: number;
    quizQuestionCategoryId?: number | undefined;
    answers?: QuizQuestionAnswerCheck[] | undefined;
}

export class QuizQuestionAnswerCheck implements IQuizQuestionAnswerCheck {
    answerId!: number;
    state?: boolean | undefined;
    answerTextMatch?: string | undefined;

    constructor(data?: IQuizQuestionAnswerCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answerId = _data["answerId"];
            this.state = _data["state"];
            this.answerTextMatch = _data["answerTextMatch"];
        }
    }

    static fromJS(data: any): QuizQuestionAnswerCheck {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionAnswerCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerId"] = this.answerId;
        data["state"] = this.state;
        data["answerTextMatch"] = this.answerTextMatch;
        return data;
    }
}

export interface IQuizQuestionAnswerCheck {
    answerId: number;
    state?: boolean | undefined;
    answerTextMatch?: string | undefined;
}

export class QuizDataQuizResultData implements IQuizDataQuizResultData {
    quizName?: string | undefined;
    spQuizTimeId!: number;
    quizTime!: number;
    maxScore!: number;
    numberOfQuiz!: number;
    passingScore!: number;
    numberAttempts!: number;
    deadline?: Date | undefined;
    numberOfUserAttempt!: number;
    quizType!: QuizType;
    isPossibility!: boolean;
    quizResults?: QuizResultDTO[] | undefined;

    constructor(data?: IQuizDataQuizResultData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizName = _data["quizName"];
            this.spQuizTimeId = _data["spQuizTimeId"];
            this.quizTime = _data["quizTime"];
            this.maxScore = _data["maxScore"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.passingScore = _data["passingScore"];
            this.numberAttempts = _data["numberAttempts"];
            this.deadline = _data["deadline"] ? new Date(_data["deadline"].toString()) : <any>undefined;
            this.numberOfUserAttempt = _data["numberOfUserAttempt"];
            this.quizType = _data["quizType"];
            this.isPossibility = _data["isPossibility"];
            if (Array.isArray(_data["quizResults"])) {
                this.quizResults = [] as any;
                for (let item of _data["quizResults"])
                    this.quizResults!.push(QuizResultDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizDataQuizResultData {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDataQuizResultData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizName"] = this.quizName;
        data["spQuizTimeId"] = this.spQuizTimeId;
        data["quizTime"] = this.quizTime;
        data["maxScore"] = this.maxScore;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["passingScore"] = this.passingScore;
        data["numberAttempts"] = this.numberAttempts;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["numberOfUserAttempt"] = this.numberOfUserAttempt;
        data["quizType"] = this.quizType;
        data["isPossibility"] = this.isPossibility;
        if (Array.isArray(this.quizResults)) {
            data["quizResults"] = [];
            for (let item of this.quizResults)
                data["quizResults"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizDataQuizResultData {
    quizName?: string | undefined;
    spQuizTimeId: number;
    quizTime: number;
    maxScore: number;
    numberOfQuiz: number;
    passingScore: number;
    numberAttempts: number;
    deadline?: Date | undefined;
    numberOfUserAttempt: number;
    quizType: QuizType;
    isPossibility: boolean;
    quizResults?: QuizResultDTO[] | undefined;
}

export class QueryResultOfCourseResult implements IQueryResultOfCourseResult {
    totalItems!: number;
    items?: CourseResult[] | undefined;

    constructor(data?: IQueryResultOfCourseResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfCourseResult {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfCourseResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfCourseResult {
    totalItems: number;
    items?: CourseResult[] | undefined;
}

export class CourseResult implements ICourseResult {
    courseId!: number;
    staffId!: number;
    userId!: number;
    name?: string | undefined;
    spCourseCategoryStr?: string | undefined;
    spCourseTypeStr?: string | undefined;
    spScienceDirectionStr?: string | undefined;
    courseName?: string | undefined;
    finalQuizResult?: number | undefined;
    finishDate?: Date | undefined;
    courseProgressLevel!: CourseProgressLevel;

    constructor(data?: ICourseResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.spCourseCategoryStr = _data["spCourseCategoryStr"];
            this.spCourseTypeStr = _data["spCourseTypeStr"];
            this.spScienceDirectionStr = _data["spScienceDirectionStr"];
            this.courseName = _data["courseName"];
            this.finalQuizResult = _data["finalQuizResult"];
            this.finishDate = _data["finishDate"] ? new Date(_data["finishDate"].toString()) : <any>undefined;
            this.courseProgressLevel = _data["courseProgressLevel"];
        }
    }

    static fromJS(data: any): CourseResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["spCourseCategoryStr"] = this.spCourseCategoryStr;
        data["spCourseTypeStr"] = this.spCourseTypeStr;
        data["spScienceDirectionStr"] = this.spScienceDirectionStr;
        data["courseName"] = this.courseName;
        data["finalQuizResult"] = this.finalQuizResult;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["courseProgressLevel"] = this.courseProgressLevel;
        return data;
    }
}

export interface ICourseResult {
    courseId: number;
    staffId: number;
    userId: number;
    name?: string | undefined;
    spCourseCategoryStr?: string | undefined;
    spCourseTypeStr?: string | undefined;
    spScienceDirectionStr?: string | undefined;
    courseName?: string | undefined;
    finalQuizResult?: number | undefined;
    finishDate?: Date | undefined;
    courseProgressLevel: CourseProgressLevel;
}

export class LandingStatisticsDTO implements ILandingStatisticsDTO {
    courseCount?: number | undefined;
    userFinishCourseCount?: number | undefined;
    users?: number | undefined;
    usersFailedCourse?: number | undefined;

    constructor(data?: ILandingStatisticsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseCount = _data["courseCount"];
            this.userFinishCourseCount = _data["userFinishCourseCount"];
            this.users = _data["users"];
            this.usersFailedCourse = _data["usersFailedCourse"];
        }
    }

    static fromJS(data: any): LandingStatisticsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LandingStatisticsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseCount"] = this.courseCount;
        data["userFinishCourseCount"] = this.userFinishCourseCount;
        data["users"] = this.users;
        data["usersFailedCourse"] = this.usersFailedCourse;
        return data;
    }
}

export interface ILandingStatisticsDTO {
    courseCount?: number | undefined;
    userFinishCourseCount?: number | undefined;
    users?: number | undefined;
    usersFailedCourse?: number | undefined;
}

export class PassportPersonInfoExt implements IPassportPersonInfoExt {
    pIssuedDate?: string | undefined;
    pPlaceBirth?: string | undefined;
    pPinpp?: string | undefined;
    pPatronym?: string | undefined;
    pSurname?: string | undefined;
    pName?: string | undefined;
    pAnswereId?: string | undefined;
    pIssuedBy?: string | undefined;
    pSex?: string | undefined;
    pSurnameEng?: string | undefined;
    pNameEng?: string | undefined;
    pPsp?: string | undefined;
    pNationality?: string | undefined;
    pNationalityId?: string | undefined;
    pCitizenship?: string | undefined;
    pDateBirth?: string | undefined;
    pValidDate?: string | undefined;
    pAnswereMessage?: string | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;

    constructor(data?: IPassportPersonInfoExt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pIssuedDate = _data["pIssuedDate"];
            this.pPlaceBirth = _data["pPlaceBirth"];
            this.pPinpp = _data["pPinpp"];
            this.pPatronym = _data["pPatronym"];
            this.pSurname = _data["pSurname"];
            this.pName = _data["pName"];
            this.pAnswereId = _data["pAnswereId"];
            this.pIssuedBy = _data["pIssuedBy"];
            this.pSex = _data["pSex"];
            this.pSurnameEng = _data["pSurnameEng"];
            this.pNameEng = _data["pNameEng"];
            this.pPsp = _data["pPsp"];
            this.pNationality = _data["pNationality"];
            this.pNationalityId = _data["pNationalityId"];
            this.pCitizenship = _data["pCitizenship"];
            this.pDateBirth = _data["pDateBirth"];
            this.pValidDate = _data["pValidDate"];
            this.pAnswereMessage = _data["pAnswereMessage"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): PassportPersonInfoExt {
        data = typeof data === 'object' ? data : {};
        let result = new PassportPersonInfoExt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pIssuedDate"] = this.pIssuedDate;
        data["pPlaceBirth"] = this.pPlaceBirth;
        data["pPinpp"] = this.pPinpp;
        data["pPatronym"] = this.pPatronym;
        data["pSurname"] = this.pSurname;
        data["pName"] = this.pName;
        data["pAnswereId"] = this.pAnswereId;
        data["pIssuedBy"] = this.pIssuedBy;
        data["pSex"] = this.pSex;
        data["pSurnameEng"] = this.pSurnameEng;
        data["pNameEng"] = this.pNameEng;
        data["pPsp"] = this.pPsp;
        data["pNationality"] = this.pNationality;
        data["pNationalityId"] = this.pNationalityId;
        data["pCitizenship"] = this.pCitizenship;
        data["pDateBirth"] = this.pDateBirth;
        data["pValidDate"] = this.pValidDate;
        data["pAnswereMessage"] = this.pAnswereMessage;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        return data;
    }
}

export interface IPassportPersonInfoExt {
    pIssuedDate?: string | undefined;
    pPlaceBirth?: string | undefined;
    pPinpp?: string | undefined;
    pPatronym?: string | undefined;
    pSurname?: string | undefined;
    pName?: string | undefined;
    pAnswereId?: string | undefined;
    pIssuedBy?: string | undefined;
    pSex?: string | undefined;
    pSurnameEng?: string | undefined;
    pNameEng?: string | undefined;
    pPsp?: string | undefined;
    pNationality?: string | undefined;
    pNationalityId?: string | undefined;
    pCitizenship?: string | undefined;
    pDateBirth?: string | undefined;
    pValidDate?: string | undefined;
    pAnswereMessage?: string | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;
}

export class GCPRequestData implements IGCPRequestData {
    birthDate?: string | undefined;
    pspSerial?: string | undefined;
    pspNumber?: string | undefined;
    cadastrGUID?: string | undefined;
    cadastrPINPP?: string | undefined;

    constructor(data?: IGCPRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"];
            this.pspSerial = _data["pspSerial"];
            this.pspNumber = _data["pspNumber"];
            this.cadastrGUID = _data["cadastrGUID"];
            this.cadastrPINPP = _data["cadastrPINPP"];
        }
    }

    static fromJS(data: any): GCPRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new GCPRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate;
        data["pspSerial"] = this.pspSerial;
        data["pspNumber"] = this.pspNumber;
        data["cadastrGUID"] = this.cadastrGUID;
        data["cadastrPINPP"] = this.cadastrPINPP;
        return data;
    }
}

export interface IGCPRequestData {
    birthDate?: string | undefined;
    pspSerial?: string | undefined;
    pspNumber?: string | undefined;
    cadastrGUID?: string | undefined;
    cadastrPINPP?: string | undefined;
}

export class StaffDTO implements IStaffDTO {
    id!: number;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    pinfl?: string | undefined;
    spSexId?: string | undefined;
    date?: string | undefined;
    birthDate!: Date;
    spNationId?: string | undefined;
    spCountryId?: string | undefined;
    internalNumber?: string | undefined;
    spRegionId?: string | undefined;
    spDistrictId?: string | undefined;
    address?: string | undefined;
    fullName?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: Date | undefined;
    passportDateEnd?: Date | undefined;
    eMail?: string | undefined;
    eMailAdditional?: string | undefined;
    phoneMain?: string | undefined;
    phoneAdditional?: string | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    inn?: string | undefined;
    inps?: string | undefined;
    login?: string | undefined;
    password?: string | undefined;
    spUserTypeId?: number | undefined;
    applicationUserId!: number;
    orgId?: number | undefined;
    imageFileGuid?: string | undefined;
    accessType!: AccessTypeUse;

    constructor(data?: IStaffDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.pinfl = _data["pinfl"];
            this.spSexId = _data["spSexId"];
            this.date = _data["date"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.spNationId = _data["spNationId"];
            this.spCountryId = _data["spCountryId"];
            this.internalNumber = _data["internalNumber"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
            this.fullName = _data["fullName"];
            this.passportSeria = _data["passportSeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportGiven = _data["passportGiven"];
            this.passportDateBegin = _data["passportDateBegin"] ? new Date(_data["passportDateBegin"].toString()) : <any>undefined;
            this.passportDateEnd = _data["passportDateEnd"] ? new Date(_data["passportDateEnd"].toString()) : <any>undefined;
            this.eMail = _data["eMail"];
            this.eMailAdditional = _data["eMailAdditional"];
            this.phoneMain = _data["phoneMain"];
            this.phoneAdditional = _data["phoneAdditional"];
            this.workInsitution = _data["workInsitution"];
            this.workPosition = _data["workPosition"];
            this.inn = _data["inn"];
            this.inps = _data["inps"];
            this.login = _data["login"];
            this.password = _data["password"];
            this.spUserTypeId = _data["spUserTypeId"];
            this.applicationUserId = _data["applicationUserId"];
            this.orgId = _data["orgId"];
            this.imageFileGuid = _data["imageFileGuid"];
            this.accessType = _data["accessType"];
        }
    }

    static fromJS(data: any): StaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["pinfl"] = this.pinfl;
        data["spSexId"] = this.spSexId;
        data["date"] = this.date;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["spNationId"] = this.spNationId;
        data["spCountryId"] = this.spCountryId;
        data["internalNumber"] = this.internalNumber;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        data["fullName"] = this.fullName;
        data["passportSeria"] = this.passportSeria;
        data["passportNumber"] = this.passportNumber;
        data["passportGiven"] = this.passportGiven;
        data["passportDateBegin"] = this.passportDateBegin ? this.passportDateBegin.toISOString() : <any>undefined;
        data["passportDateEnd"] = this.passportDateEnd ? this.passportDateEnd.toISOString() : <any>undefined;
        data["eMail"] = this.eMail;
        data["eMailAdditional"] = this.eMailAdditional;
        data["phoneMain"] = this.phoneMain;
        data["phoneAdditional"] = this.phoneAdditional;
        data["workInsitution"] = this.workInsitution;
        data["workPosition"] = this.workPosition;
        data["inn"] = this.inn;
        data["inps"] = this.inps;
        data["login"] = this.login;
        data["password"] = this.password;
        data["spUserTypeId"] = this.spUserTypeId;
        data["applicationUserId"] = this.applicationUserId;
        data["orgId"] = this.orgId;
        data["imageFileGuid"] = this.imageFileGuid;
        data["accessType"] = this.accessType;
        return data;
    }
}

export interface IStaffDTO {
    id: number;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    pinfl?: string | undefined;
    spSexId?: string | undefined;
    date?: string | undefined;
    birthDate: Date;
    spNationId?: string | undefined;
    spCountryId?: string | undefined;
    internalNumber?: string | undefined;
    spRegionId?: string | undefined;
    spDistrictId?: string | undefined;
    address?: string | undefined;
    fullName?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: Date | undefined;
    passportDateEnd?: Date | undefined;
    eMail?: string | undefined;
    eMailAdditional?: string | undefined;
    phoneMain?: string | undefined;
    phoneAdditional?: string | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    inn?: string | undefined;
    inps?: string | undefined;
    login?: string | undefined;
    password?: string | undefined;
    spUserTypeId?: number | undefined;
    applicationUserId: number;
    orgId?: number | undefined;
    imageFileGuid?: string | undefined;
    accessType: AccessTypeUse;
}

export enum AccessTypeUse {
    DisableAccess = 0,
    EnableAccess = 1,
    RejectionAccess = 2,
}

export class UserStaff implements IUserStaff {
    staffId!: number;
    userId!: number;

    constructor(data?: IUserStaff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserStaff {
        data = typeof data === 'object' ? data : {};
        let result = new UserStaff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUserStaff {
    staffId: number;
    userId: number;
}

export class GCPRequestData2 implements IGCPRequestData2 {
    birthDate?: string | undefined;
    pspSerial?: string | undefined;
    pspNumber?: string | undefined;
    cadastrGUID?: string | undefined;
    cadastrPINPP?: string | undefined;
    passportSeriaAndNum?: string | undefined;
    pinfl?: string | undefined;
    typeIdentityDoc?: string | undefined;
    orgId!: number;
    email?: string | undefined;
    phoneNumer?: string | undefined;

    constructor(data?: IGCPRequestData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"];
            this.pspSerial = _data["pspSerial"];
            this.pspNumber = _data["pspNumber"];
            this.cadastrGUID = _data["cadastrGUID"];
            this.cadastrPINPP = _data["cadastrPINPP"];
            this.passportSeriaAndNum = _data["passportSeriaAndNum"];
            this.pinfl = _data["pinfl"];
            this.typeIdentityDoc = _data["typeIdentityDoc"];
            this.orgId = _data["orgId"];
            this.email = _data["email"];
            this.phoneNumer = _data["phoneNumer"];
        }
    }

    static fromJS(data: any): GCPRequestData2 {
        data = typeof data === 'object' ? data : {};
        let result = new GCPRequestData2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate;
        data["pspSerial"] = this.pspSerial;
        data["pspNumber"] = this.pspNumber;
        data["cadastrGUID"] = this.cadastrGUID;
        data["cadastrPINPP"] = this.cadastrPINPP;
        data["passportSeriaAndNum"] = this.passportSeriaAndNum;
        data["pinfl"] = this.pinfl;
        data["typeIdentityDoc"] = this.typeIdentityDoc;
        data["orgId"] = this.orgId;
        data["email"] = this.email;
        data["phoneNumer"] = this.phoneNumer;
        return data;
    }
}

export interface IGCPRequestData2 {
    birthDate?: string | undefined;
    pspSerial?: string | undefined;
    pspNumber?: string | undefined;
    cadastrGUID?: string | undefined;
    cadastrPINPP?: string | undefined;
    passportSeriaAndNum?: string | undefined;
    pinfl?: string | undefined;
    typeIdentityDoc?: string | undefined;
    orgId: number;
    email?: string | undefined;
    phoneNumer?: string | undefined;
}

export class SendData implements ISendData {
    id!: number;
    pinfl?: string | undefined;

    constructor(data?: ISendData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pinfl = _data["pinfl"];
        }
    }

    static fromJS(data: any): SendData {
        data = typeof data === 'object' ? data : {};
        let result = new SendData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pinfl"] = this.pinfl;
        return data;
    }
}

export interface ISendData {
    id: number;
    pinfl?: string | undefined;
}

export class QueryResultOfStaffDTO implements IQueryResultOfStaffDTO {
    totalItems!: number;
    items?: StaffDTO[] | undefined;

    constructor(data?: IQueryResultOfStaffDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfStaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfStaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfStaffDTO {
    totalItems: number;
    items?: StaffDTO[] | undefined;
}

export class CourseCountStatisticDTO implements ICourseCountStatisticDTO {
    courseCount!: number;
    averageScore!: number;

    constructor(data?: ICourseCountStatisticDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseCount = _data["courseCount"];
            this.averageScore = _data["averageScore"];
        }
    }

    static fromJS(data: any): CourseCountStatisticDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseCountStatisticDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseCount"] = this.courseCount;
        data["averageScore"] = this.averageScore;
        return data;
    }
}

export interface ICourseCountStatisticDTO {
    courseCount: number;
    averageScore: number;
}

export class QueryResultOfCourseStatisticsDTO implements IQueryResultOfCourseStatisticsDTO {
    totalItems!: number;
    items?: CourseStatisticsDTO[] | undefined;

    constructor(data?: IQueryResultOfCourseStatisticsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseStatisticsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfCourseStatisticsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfCourseStatisticsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfCourseStatisticsDTO {
    totalItems: number;
    items?: CourseStatisticsDTO[] | undefined;
}

export class CourseStatisticsDTO implements ICourseStatisticsDTO {
    courseName?: string | undefined;
    numberOfCompletedCourse!: number;
    numberOfCurrentlyStudying!: number;
    numberOfWhoFailedCourse!: number;
    averagePassingScore!: number;
    averageTimeCompleteCourse!: number;
    courseId!: number;

    constructor(data?: ICourseStatisticsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseName = _data["courseName"];
            this.numberOfCompletedCourse = _data["numberOfCompletedCourse"];
            this.numberOfCurrentlyStudying = _data["numberOfCurrentlyStudying"];
            this.numberOfWhoFailedCourse = _data["numberOfWhoFailedCourse"];
            this.averagePassingScore = _data["averagePassingScore"];
            this.averageTimeCompleteCourse = _data["averageTimeCompleteCourse"];
            this.courseId = _data["courseId"];
        }
    }

    static fromJS(data: any): CourseStatisticsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseStatisticsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseName"] = this.courseName;
        data["numberOfCompletedCourse"] = this.numberOfCompletedCourse;
        data["numberOfCurrentlyStudying"] = this.numberOfCurrentlyStudying;
        data["numberOfWhoFailedCourse"] = this.numberOfWhoFailedCourse;
        data["averagePassingScore"] = this.averagePassingScore;
        data["averageTimeCompleteCourse"] = this.averageTimeCompleteCourse;
        data["courseId"] = this.courseId;
        return data;
    }
}

export interface ICourseStatisticsDTO {
    courseName?: string | undefined;
    numberOfCompletedCourse: number;
    numberOfCurrentlyStudying: number;
    numberOfWhoFailedCourse: number;
    averagePassingScore: number;
    averageTimeCompleteCourse: number;
    courseId: number;
}

export class ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString implements IValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString {
    item1!: QueryResultOfStatisticsForOneCourseDTO;
    item2!: string;

    constructor(data?: IValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item1 = new QueryResultOfStatisticsForOneCourseDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"] ? QueryResultOfStatisticsForOneCourseDTO.fromJS(_data["item1"]) : new QueryResultOfStatisticsForOneCourseDTO();
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1 ? this.item1.toJSON() : <any>undefined;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfQueryResultOfStatisticsForOneCourseDTOAndString {
    item1: QueryResultOfStatisticsForOneCourseDTO;
    item2: string;
}

export class QueryResultOfStatisticsForOneCourseDTO implements IQueryResultOfStatisticsForOneCourseDTO {
    totalItems!: number;
    items?: StatisticsForOneCourseDTO[] | undefined;

    constructor(data?: IQueryResultOfStatisticsForOneCourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticsForOneCourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfStatisticsForOneCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfStatisticsForOneCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfStatisticsForOneCourseDTO {
    totalItems: number;
    items?: StatisticsForOneCourseDTO[] | undefined;
}

export class StatisticsForOneCourseDTO implements IStatisticsForOneCourseDTO {
    fullName?: string | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    startDate!: Date;
    progress!: number;
    endDate?: Date | undefined;
    time!: number;
    passingScore?: string | undefined;
    result!: number;
    certificate?: string | undefined;
    certificateValidityPeriod?: Date | undefined;
    courseId!: number;
    userId!: number;
    progressStatus!: CourseProgressLevel;

    constructor(data?: IStatisticsForOneCourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.workInsitution = _data["workInsitution"];
            this.workPosition = _data["workPosition"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.time = _data["time"];
            this.passingScore = _data["passingScore"];
            this.result = _data["result"];
            this.certificate = _data["certificate"];
            this.certificateValidityPeriod = _data["certificateValidityPeriod"] ? new Date(_data["certificateValidityPeriod"].toString()) : <any>undefined;
            this.courseId = _data["courseId"];
            this.userId = _data["userId"];
            this.progressStatus = _data["progressStatus"];
        }
    }

    static fromJS(data: any): StatisticsForOneCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsForOneCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["workInsitution"] = this.workInsitution;
        data["workPosition"] = this.workPosition;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["time"] = this.time;
        data["passingScore"] = this.passingScore;
        data["result"] = this.result;
        data["certificate"] = this.certificate;
        data["certificateValidityPeriod"] = this.certificateValidityPeriod ? this.certificateValidityPeriod.toISOString() : <any>undefined;
        data["courseId"] = this.courseId;
        data["userId"] = this.userId;
        data["progressStatus"] = this.progressStatus;
        return data;
    }
}

export interface IStatisticsForOneCourseDTO {
    fullName?: string | undefined;
    workInsitution?: string | undefined;
    workPosition?: string | undefined;
    startDate: Date;
    progress: number;
    endDate?: Date | undefined;
    time: number;
    passingScore?: string | undefined;
    result: number;
    certificate?: string | undefined;
    certificateValidityPeriod?: Date | undefined;
    courseId: number;
    userId: number;
    progressStatus: CourseProgressLevel;
}

export class CreditsSumModel implements ICreditsSumModel {
    userId!: number;
    orgId!: number;
    startDate!: Date;
    endDate!: Date;

    constructor(data?: ICreditsSumModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.orgId = _data["orgId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditsSumModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditsSumModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["orgId"] = this.orgId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreditsSumModel {
    userId: number;
    orgId: number;
    startDate: Date;
    endDate: Date;
}

export class TestResultDTO implements ITestResultDTO {
    testId!: number;
    staffId!: number;
    numberCorrectAnswer!: number;
    numberWrongAnswer!: number;
    attempt!: number;
    passTestStatus!: PassTestStatus;

    constructor(data?: ITestResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testId = _data["testId"];
            this.staffId = _data["staffId"];
            this.numberCorrectAnswer = _data["numberCorrectAnswer"];
            this.numberWrongAnswer = _data["numberWrongAnswer"];
            this.attempt = _data["attempt"];
            this.passTestStatus = _data["passTestStatus"];
        }
    }

    static fromJS(data: any): TestResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TestResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testId"] = this.testId;
        data["staffId"] = this.staffId;
        data["numberCorrectAnswer"] = this.numberCorrectAnswer;
        data["numberWrongAnswer"] = this.numberWrongAnswer;
        data["attempt"] = this.attempt;
        data["passTestStatus"] = this.passTestStatus;
        return data;
    }
}

export interface ITestResultDTO {
    testId: number;
    staffId: number;
    numberCorrectAnswer: number;
    numberWrongAnswer: number;
    attempt: number;
    passTestStatus: PassTestStatus;
}

export class TrainerTaskAnswerDTO implements ITrainerTaskAnswerDTO {
    trainerTaskId!: number;
    staffId!: number;
    textAnswer?: string | undefined;
    status!: TrainerTaskAnswerStatus;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    taskScore?: TrainerTaskScore | undefined;

    constructor(data?: ITrainerTaskAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainerTaskId = _data["trainerTaskId"];
            this.staffId = _data["staffId"];
            this.textAnswer = _data["textAnswer"];
            this.status = _data["status"];
            this.imageFileId = _data["imageFileId"];
            this.fileDocumentId = _data["fileDocumentId"];
            this.audioFileId = _data["audioFileId"];
            this.videoFileId = _data["videoFileId"];
            this.taskScore = _data["taskScore"] ? TrainerTaskScore.fromJS(_data["taskScore"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerTaskAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerTaskAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerTaskId"] = this.trainerTaskId;
        data["staffId"] = this.staffId;
        data["textAnswer"] = this.textAnswer;
        data["status"] = this.status;
        data["imageFileId"] = this.imageFileId;
        data["fileDocumentId"] = this.fileDocumentId;
        data["audioFileId"] = this.audioFileId;
        data["videoFileId"] = this.videoFileId;
        data["taskScore"] = this.taskScore ? this.taskScore.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerTaskAnswerDTO {
    trainerTaskId: number;
    staffId: number;
    textAnswer?: string | undefined;
    status: TrainerTaskAnswerStatus;
    imageFileId?: string | undefined;
    fileDocumentId?: string | undefined;
    audioFileId?: string | undefined;
    videoFileId?: string | undefined;
    taskScore?: TrainerTaskScore | undefined;
}

export class TrainerTaskScoreDTO implements ITrainerTaskScoreDTO {
    trainerTaskAnswerId!: number;
    comment?: string | undefined;
    score!: number;

    constructor(data?: ITrainerTaskScoreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainerTaskAnswerId = _data["trainerTaskAnswerId"];
            this.comment = _data["comment"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): TrainerTaskScoreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerTaskScoreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerTaskAnswerId"] = this.trainerTaskAnswerId;
        data["comment"] = this.comment;
        data["score"] = this.score;
        return data;
    }
}

export interface ITrainerTaskScoreDTO {
    trainerTaskAnswerId: number;
    comment?: string | undefined;
    score: number;
}

export class KeyValuePairOfStringAndString implements IKeyValuePairOfStringAndString {
    key!: string;
    value!: string;

    constructor(data?: IKeyValuePairOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairOfStringAndString {
    key: string;
    value: string;
}

export class TranslateMeta implements ITranslateMeta {
    lang?: string | undefined;
    module?: string | undefined;

    constructor(data?: ITranslateMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lang = _data["lang"];
            this.module = _data["module"];
        }
    }

    static fromJS(data: any): TranslateMeta {
        data = typeof data === 'object' ? data : {};
        let result = new TranslateMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lang"] = this.lang;
        data["module"] = this.module;
        return data;
    }
}

export interface ITranslateMeta {
    lang?: string | undefined;
    module?: string | undefined;
}

export class Translation extends EntityBase implements ITranslation {
    valueUz?: string | undefined;
    valueEng?: string | undefined;
    valueRu?: string | undefined;
    valueKr?: string | undefined;
    project!: Project;
    code?: string | undefined;
    module?: string | undefined;

    constructor(data?: ITranslation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.valueUz = _data["valueUz"];
            this.valueEng = _data["valueEng"];
            this.valueRu = _data["valueRu"];
            this.valueKr = _data["valueKr"];
            this.project = _data["project"];
            this.code = _data["code"];
            this.module = _data["module"];
        }
    }

    static override fromJS(data: any): Translation {
        data = typeof data === 'object' ? data : {};
        let result = new Translation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueUz"] = this.valueUz;
        data["valueEng"] = this.valueEng;
        data["valueRu"] = this.valueRu;
        data["valueKr"] = this.valueKr;
        data["project"] = this.project;
        data["code"] = this.code;
        data["module"] = this.module;
        super.toJSON(data);
        return data;
    }
}

export interface ITranslation extends IEntityBase {
    valueUz?: string | undefined;
    valueEng?: string | undefined;
    valueRu?: string | undefined;
    valueKr?: string | undefined;
    project: Project;
    code?: string | undefined;
    module?: string | undefined;
}

export enum Project {
    Student = 0,
    Study = 1,
}

export class TranslationsDto implements ITranslationsDto {
    count!: number;
    translations?: Translation[] | undefined;

    constructor(data?: ITranslationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["translations"])) {
                this.translations = [] as any;
                for (let item of _data["translations"])
                    this.translations!.push(Translation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TranslationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranslationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.translations)) {
            data["translations"] = [];
            for (let item of this.translations)
                data["translations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITranslationsDto {
    count: number;
    translations?: Translation[] | undefined;
}

export class VideoContentDTO implements IVideoContentDTO {
    id!: number;
    lessonId!: number;
    fileVideoId!: string;
    title?: string | undefined;
    description?: string | undefined;
    youTubeUrl?: string | undefined;
    localUrl?: string | undefined;
    videoUploadType!: VideoUploadType;

    constructor(data?: IVideoContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.fileVideoId = _data["fileVideoId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.youTubeUrl = _data["youTubeUrl"];
            this.localUrl = _data["localUrl"];
            this.videoUploadType = _data["videoUploadType"];
        }
    }

    static fromJS(data: any): VideoContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VideoContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["fileVideoId"] = this.fileVideoId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["youTubeUrl"] = this.youTubeUrl;
        data["localUrl"] = this.localUrl;
        data["videoUploadType"] = this.videoUploadType;
        return data;
    }
}

export interface IVideoContentDTO {
    id: number;
    lessonId: number;
    fileVideoId: string;
    title?: string | undefined;
    description?: string | undefined;
    youTubeUrl?: string | undefined;
    localUrl?: string | undefined;
    videoUploadType: VideoUploadType;
}

export class QueryResultOfVideoContentDTO implements IQueryResultOfVideoContentDTO {
    totalItems!: number;
    items?: VideoContentDTO[] | undefined;

    constructor(data?: IQueryResultOfVideoContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VideoContentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryResultOfVideoContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfVideoContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueryResultOfVideoContentDTO {
    totalItems: number;
    items?: VideoContentDTO[] | undefined;
}

export class VideoQuizAnswerDTO implements IVideoQuizAnswerDTO {
    id?: number | undefined;
    videoQuizQuestionId!: number;
    answerText?: string | undefined;
    isRight!: boolean;

    constructor(data?: IVideoQuizAnswerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.videoQuizQuestionId = _data["videoQuizQuestionId"];
            this.answerText = _data["answerText"];
            this.isRight = _data["isRight"];
        }
    }

    static fromJS(data: any): VideoQuizAnswerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuizAnswerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["videoQuizQuestionId"] = this.videoQuizQuestionId;
        data["answerText"] = this.answerText;
        data["isRight"] = this.isRight;
        return data;
    }
}

export interface IVideoQuizAnswerDTO {
    id?: number | undefined;
    videoQuizQuestionId: number;
    answerText?: string | undefined;
    isRight: boolean;
}

export class VideoQuizDTO implements IVideoQuizDTO {
    id?: number | undefined;
    videoTestId!: number;
    timeCode!: number;
    quizTime!: number;
    maxScore?: number | undefined;
    passingScore?: number | undefined;
    numberOfQuiz!: number;
    numberAttempts!: number;
    timeLimit!: boolean;
    repeatIfWrong!: boolean;
    showCorrectAnswer!: boolean;
    quizQuestions?: VideoQuizQuestion[] | undefined;

    constructor(data?: IVideoQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.videoTestId = _data["videoTestId"];
            this.timeCode = _data["timeCode"];
            this.quizTime = _data["quizTime"];
            this.maxScore = _data["maxScore"];
            this.passingScore = _data["passingScore"];
            this.numberOfQuiz = _data["numberOfQuiz"];
            this.numberAttempts = _data["numberAttempts"];
            this.timeLimit = _data["timeLimit"];
            this.repeatIfWrong = _data["repeatIfWrong"];
            this.showCorrectAnswer = _data["showCorrectAnswer"];
            if (Array.isArray(_data["quizQuestions"])) {
                this.quizQuestions = [] as any;
                for (let item of _data["quizQuestions"])
                    this.quizQuestions!.push(VideoQuizQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoQuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["videoTestId"] = this.videoTestId;
        data["timeCode"] = this.timeCode;
        data["quizTime"] = this.quizTime;
        data["maxScore"] = this.maxScore;
        data["passingScore"] = this.passingScore;
        data["numberOfQuiz"] = this.numberOfQuiz;
        data["numberAttempts"] = this.numberAttempts;
        data["timeLimit"] = this.timeLimit;
        data["repeatIfWrong"] = this.repeatIfWrong;
        data["showCorrectAnswer"] = this.showCorrectAnswer;
        if (Array.isArray(this.quizQuestions)) {
            data["quizQuestions"] = [];
            for (let item of this.quizQuestions)
                data["quizQuestions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVideoQuizDTO {
    id?: number | undefined;
    videoTestId: number;
    timeCode: number;
    quizTime: number;
    maxScore?: number | undefined;
    passingScore?: number | undefined;
    numberOfQuiz: number;
    numberAttempts: number;
    timeLimit: boolean;
    repeatIfWrong: boolean;
    showCorrectAnswer: boolean;
    quizQuestions?: VideoQuizQuestion[] | undefined;
}

export class VideoQuizQuestionDTO implements IVideoQuizQuestionDTO {
    id?: number | undefined;
    videoQuizId!: number;
    questionText?: string | undefined;
    questionAnswer?: VideoQuizAnswer[] | undefined;

    constructor(data?: IVideoQuizQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.videoQuizId = _data["videoQuizId"];
            this.questionText = _data["questionText"];
            if (Array.isArray(_data["questionAnswer"])) {
                this.questionAnswer = [] as any;
                for (let item of _data["questionAnswer"])
                    this.questionAnswer!.push(VideoQuizAnswer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoQuizQuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VideoQuizQuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["videoQuizId"] = this.videoQuizId;
        data["questionText"] = this.questionText;
        if (Array.isArray(this.questionAnswer)) {
            data["questionAnswer"] = [];
            for (let item of this.questionAnswer)
                data["questionAnswer"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVideoQuizQuestionDTO {
    id?: number | undefined;
    videoQuizId: number;
    questionText?: string | undefined;
    questionAnswer?: VideoQuizAnswer[] | undefined;
}

export class VideoTestDTO implements IVideoTestDTO {
    generalPartModuleId?: number | undefined;
    id?: number | undefined;
    videoTestName?: string | undefined;
    description?: string | undefined;
    videoFileId!: string;
    quizesTimeCodes?: { [key: string]: number; } | undefined;
    videoQuizzes?: VideoQuizDTO[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;

    constructor(data?: IVideoTestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalPartModuleId = _data["generalPartModuleId"];
            this.id = _data["id"];
            this.videoTestName = _data["videoTestName"];
            this.description = _data["description"];
            this.videoFileId = _data["videoFileId"];
            if (_data["quizesTimeCodes"]) {
                this.quizesTimeCodes = {} as any;
                for (let key in _data["quizesTimeCodes"]) {
                    if (_data["quizesTimeCodes"].hasOwnProperty(key))
                        (<any>this.quizesTimeCodes)![key] = _data["quizesTimeCodes"][key];
                }
            }
            if (Array.isArray(_data["videoQuizzes"])) {
                this.videoQuizzes = [] as any;
                for (let item of _data["videoQuizzes"])
                    this.videoQuizzes!.push(VideoQuizDTO.fromJS(item));
            }
            this.generalPartModule = _data["generalPartModule"] ? GeneralPartModule.fromJS(_data["generalPartModule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoTestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VideoTestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalPartModuleId"] = this.generalPartModuleId;
        data["id"] = this.id;
        data["videoTestName"] = this.videoTestName;
        data["description"] = this.description;
        data["videoFileId"] = this.videoFileId;
        if (this.quizesTimeCodes) {
            data["quizesTimeCodes"] = {};
            for (let key in this.quizesTimeCodes) {
                if (this.quizesTimeCodes.hasOwnProperty(key))
                    (<any>data["quizesTimeCodes"])[key] = (<any>this.quizesTimeCodes)[key];
            }
        }
        if (Array.isArray(this.videoQuizzes)) {
            data["videoQuizzes"] = [];
            for (let item of this.videoQuizzes)
                data["videoQuizzes"].push(item.toJSON());
        }
        data["generalPartModule"] = this.generalPartModule ? this.generalPartModule.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVideoTestDTO {
    generalPartModuleId?: number | undefined;
    id?: number | undefined;
    videoTestName?: string | undefined;
    description?: string | undefined;
    videoFileId: string;
    quizesTimeCodes?: { [key: string]: number; } | undefined;
    videoQuizzes?: VideoQuizDTO[] | undefined;
    generalPartModule?: GeneralPartModule | undefined;
}

export class WebContentDTO implements IWebContentDTO {
    id!: number;
    lessonId!: number;
    title?: string | undefined;
    description?: string | undefined;
    webAddressUrl?: string | undefined;

    constructor(data?: IWebContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessonId = _data["lessonId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.webAddressUrl = _data["webAddressUrl"];
        }
    }

    static fromJS(data: any): WebContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WebContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessonId"] = this.lessonId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["webAddressUrl"] = this.webAddressUrl;
        return data;
    }
}

export interface IWebContentDTO {
    id: number;
    lessonId: number;
    title?: string | undefined;
    description?: string | undefined;
    webAddressUrl?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            if(typeof FileReader!=='undefined')
            {
              let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
            }
        }
    });
}
